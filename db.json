{
    "meta": {
        "version": 1,
        "warehouse": "5.0.1"
    },
    "models": {
        "Asset": [
            {
                "_id": "source/images/el-dialog在数组中的更新问题/列表不展示.webp",
                "path": "images/el-dialog在数组中的更新问题/列表不展示.webp",
                "modified": 0,
                "renderable": 0
            },
            {
                "_id": "themes/cage/source/css/archive.styl",
                "path": "css/archive.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/article.styl",
                "path": "css/article.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/cage-friends.styl",
                "path": "css/cage-friends.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/constants.styl",
                "path": "css/constants.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/index.styl",
                "path": "css/index.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/layout.styl",
                "path": "css/layout.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/media.styl",
                "path": "css/media.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/reset.styl",
                "path": "css/reset.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/right-column.styl",
                "path": "css/right-column.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/post.styl",
                "path": "css/post.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/sidebar.styl",
                "path": "css/sidebar.styl",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/images/cloud.png",
                "path": "images/cloud.png",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/images/favicon.png",
                "path": "images/favicon.png",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/js/cloud.js",
                "path": "js/cloud.js",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/lib/lazysizes.min.js",
                "path": "lib/lazysizes.min.js",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/js/code-copy.js",
                "path": "js/code-copy.js",
                "modified": 0,
                "renderable": 1
            },
            {
                "_id": "themes/cage/source/css/code-copy.styl",
                "path": "css/code-copy.styl",
                "modified": 0,
                "renderable": 1
            }
        ],
        "Cache": [
            {
                "_id": "source/about.md",
                "hash": "bb9c03246bead87f48324b4b04d41c0c0e2dcb8f",
                "modified": 1738637558746
            },
            {
                "_id": "source/archive.md",
                "hash": "96a01db45741c99e78b6d25286bdba910f66bc88",
                "modified": 1717171094000
            },
            {
                "_id": "source/friends.md",
                "hash": "5fae008c22fb2d9a7eaa915fc3c4da0c7249648e",
                "modified": 1738603819335
            },
            {
                "_id": "source/_posts/el-dialog在数组中的更新问题.md",
                "hash": "e83bc0cbb795dc8ca8c1f23b91f9011717d62531",
                "modified": 1738650748572
            },
            {
                "_id": "source/_posts/el-table-column设置fixed的影响.md",
                "hash": "4c0124540d445cddbabb2a17a0e5a036d84792f0",
                "modified": 1738650695054
            },
            {
                "_id": "source/_posts/樊笼.md",
                "hash": "c655b469abcd5d02b0491fe013143f7a71c67df9",
                "modified": 1738651485818
            },
            {
                "_id": "source/images/el-dialog在数组中的更新问题/列表不展示.webp",
                "hash": "c006e5d7f6d93eec8a5c17cc37b4c06324ad1924",
                "modified": 1738136404571
            },
            {
                "_id": "themes/cage/_config.yml",
                "hash": "2658373a51490313d5133d5eb37e054d81c5f2a6",
                "modified": 1738648214992
            },
            {
                "_id": "themes/cage/languages/default.yml",
                "hash": "7912d1f64c88b0fa4c3506275b722ec7180981e3",
                "modified": 1731850597264
            },
            {
                "_id": "themes/cage/languages/en.yml",
                "hash": "36fcfbb3928e9a52debc342ba68eec8e28426d20",
                "modified": 1717171094000
            },
            {
                "_id": "themes/cage/languages/zh-CN.yml",
                "hash": "7912d1f64c88b0fa4c3506275b722ec7180981e3",
                "modified": 1717171094000
            },
            {
                "_id": "themes/cage/layout/archives.ejs",
                "hash": "3e73929d33a49822f454c4ed163366c990074723",
                "modified": 1738601648780
            },
            {
                "_id": "themes/cage/layout/friends.ejs",
                "hash": "e33cdb1fe881c9460695bda7cb5379b77d1ed13f",
                "modified": 1738599226217
            },
            {
                "_id": "themes/cage/layout/layout.ejs",
                "hash": "d163a8cdc18bf439ad144f8173d3710b76d5936b",
                "modified": 1738647628292
            },
            {
                "_id": "themes/cage/layout/index.ejs",
                "hash": "21bd8e4480cc8d0c7bd2e261e27e403532c14c71",
                "modified": 1738602054641
            },
            {
                "_id": "themes/cage/layout/post.ejs",
                "hash": "31bfb54c94c7971498c46ad6d54e9232353a8966",
                "modified": 1738648153218
            },
            {
                "_id": "themes/cage/layout/components/copyright.ejs",
                "hash": "27216538349ea2e6842c2d3b331556ead0f1da3e",
                "modified": 1731849486514
            },
            {
                "_id": "themes/cage/layout/components/friends.ejs",
                "hash": "3674e6c8e41784816ca8e2dcdeb76fb00a0312d4",
                "modified": 1738604465969
            },
            {
                "_id": "themes/cage/layout/components/header.ejs",
                "hash": "9d970eca2abd3151614aadf55e34ecc05a5b93f8",
                "modified": 1738601520989
            },
            {
                "_id": "themes/cage/layout/components/loading.ejs",
                "hash": "b01c95dbf7a1349f930616b4356804b4e0628079",
                "modified": 1738606154460
            },
            {
                "_id": "themes/cage/layout/components/sidebar.ejs",
                "hash": "858cb15187eebeb5a952133059521f0f44caa14c",
                "modified": 1738637762973
            },
            {
                "_id": "themes/cage/layout/widgets/archive.ejs",
                "hash": "95233077a8c87cc83a721b29fb7267167af10cac",
                "modified": 1738324839336
            },
            {
                "_id": "themes/cage/layout/components/right-column.ejs",
                "hash": "92b4e2d29460a353050b8a780048f8e6910c9c18",
                "modified": 1738638295354
            },
            {
                "_id": "themes/cage/layout/widgets/category.ejs",
                "hash": "7618870fa8b1f27eadcbb3b812ed1fd2f917a196",
                "modified": 1738324845743
            },
            {
                "_id": "themes/cage/layout/widgets/tagcloud.ejs",
                "hash": "bfdcdf110b8697a47630640c528b0ba41194d3fb",
                "modified": 1738608051718
            },
            {
                "_id": "themes/cage/layout/widgets/social.ejs",
                "hash": "4418af9c8f94563be3acf6ceddd4a171dfa55d27",
                "modified": 1738644325822
            },
            {
                "_id": "themes/cage/scripts/utils/image_auto_lazyload.js",
                "hash": "c40d63501faec872607bc99c1c226c5ea2e70854",
                "modified": 1731858391164
            },
            {
                "_id": "themes/cage/source/css/archive.styl",
                "hash": "41e77778c6a06c15c4a0e9aeb02e009e96cabc54",
                "modified": 1738601728598
            },
            {
                "_id": "themes/cage/source/css/cage-friends.styl",
                "hash": "b7aaccc081245ac4ecb9f2e5066a8ddfc0c98f93",
                "modified": 1738606261552
            },
            {
                "_id": "themes/cage/source/css/article.styl",
                "hash": "6e238ec6bc9ed779a72b90a8923c3d3452c7e039",
                "modified": 1738645997624
            },
            {
                "_id": "themes/cage/source/css/constants.styl",
                "hash": "d8489687112be08b3c696e5ccfa141523fb1aa4f",
                "modified": 1738645161447
            },
            {
                "_id": "themes/cage/source/css/index.styl",
                "hash": "b83a658597efaeaba60c77a73d4c764fc25d6353",
                "modified": 1738607602552
            },
            {
                "_id": "themes/cage/source/css/layout.styl",
                "hash": "1234682f8f46e17cbeaf26c344ef7b2a28b1389b",
                "modified": 1738647831092
            },
            {
                "_id": "themes/cage/source/css/media.styl",
                "hash": "27724995fb81ebfc990cf9088819abd5d74b7480",
                "modified": 1738637312900
            },
            {
                "_id": "themes/cage/source/css/reset.styl",
                "hash": "d1d940ec59c79e5d48be5cb4a26d625c8929ae8e",
                "modified": 1738513902222
            },
            {
                "_id": "themes/cage/source/css/right-column.styl",
                "hash": "f52857b208bf5aa30b9bdde600d674acfb7766d7",
                "modified": 1738603408836
            },
            {
                "_id": "themes/cage/source/css/post.styl",
                "hash": "b4ad81a97d527c49e9edf5f0a7aa6097f1eac622",
                "modified": 1738645140831
            },
            {
                "_id": "themes/cage/source/css/sidebar.styl",
                "hash": "c7b0f60421f49a91bd792c7584c04f17ca685952",
                "modified": 1738645151423
            },
            {
                "_id": "themes/cage/source/images/cloud.png",
                "hash": "54cdea9f816596fafbef6b376f25d89102bad12e",
                "modified": 1728349662000
            },
            {
                "_id": "themes/cage/source/js/cloud.js",
                "hash": "c3995163b04c36a12c382fa32d0d5a8bacde3072",
                "modified": 1738604906885
            },
            {
                "_id": "themes/cage/source/lib/lazysizes.min.js",
                "hash": "fa55e2cff078381e5365d95782a95a787d0b7192",
                "modified": 1731851341194
            },
            {
                "_id": "themes/cage/layout/components/comments/giscus.ejs",
                "hash": "2a790b7237ae66ed75b0951d42682cc9d7c49e25",
                "modified": 1738642285999
            },
            {
                "_id": "themes/cage/layout/components/comments/gitalk.ejs",
                "hash": "c862d4ecaca1cc322d3ebf9912bdd138f4755164",
                "modified": 1717171094000
            },
            {
                "_id": "themes/cage/source/images/favicon.png",
                "hash": "0af27a464389fa38264414c802da7d0072c43209",
                "modified": 1731831546050
            },
            {
                "_id": "themes/cage/source/css/code-copy.styl",
                "hash": "14ddb6c6a01f0890667a39216936c3d82d199930",
                "modified": 1738648015112
            },
            {
                "_id": "themes/cage/source/js/code-copy.js",
                "hash": "a8911b8d647361a9eebf48e9ec8b99242d755eee",
                "modified": 1738648073636
            }
        ],
        "Category": [
            {
                "name": "前端",
                "_id": "cm6q1s4oz0004f4wb1gt22rtz"
            },
            {
                "name": "碎碎念",
                "_id": "cm6q1s4p5000if4wb20dr2qsl"
            }
        ],
        "Data": [],
        "Page": [
            {
                "title": "关于本人",
                "_content": "\n<iframe style=\"width:748px;height:421px;margin:0 auto;display: flex;\" src=\"//player.bilibili.com/player.html?bvid=BV1fD1dYLECZ\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n\n<hr />\n\n## 关于我\n<p>\n高中开始经同学介绍接触二次元文化，但是家里直到高二快结束才装宽带，所以基本是蹭同学和亲戚家的网追番和下资源。\n<br/>\n<br/>\n由于高考结束之前没怎么接触计算机，高考分数又没有特别多选择余地，所以纯粹出于好奇<i>(甚至都算不上兴趣)</i>，选择了软件工程专业<del><i>(天知道那时候怎么想的，好险当年没选信息与计算科学这种数学类专业)</i></del>。\n<br/>\n在大学里又在同学的影响下接触了 WEB 前端、网抑云、STEAM、VR，互联网的开放和包容为我打开了信息技术的大门，<del>同时也提升了二次元浓度和加重了网瘾</del>。就像《冰菓》里描绘的那样，大学的这段时光或许是我人生中为数不多的玫瑰色生活<del>(虽然没有期望的恋爱戏码)</del>。\n<br/>\n<br/>\n之后19年毕业，大家各奔前程，我也懵懵懂懂的开始了社畜生涯，就这么按部就班的忙碌到了现在。\n<br/>\n虽然历经了三年魔幻的疫情时光，这几年世界格局也是风云变幻。\n<br/>\n但是就我自己而言，工作后的生活实在乏善可陈，完全可以用循规蹈矩来形容。\n<br/>\n唯一称得上记忆深刻的是在基金上亏了不小的一笔，之后也在工作中接触到了一些浅薄的金融知识，现在对于金融市场的态度谨慎了许多。\n<br/>\n</p>\n\n## 未来\n<p>\n很迷茫，但是不管怎样，我的故事还没有结束，我希望能让生活变好。\n</p>",
                "source": "about.md",
                "raw": "---\ntitle: 关于本人\n---\n\n<iframe style=\"width:748px;height:421px;margin:0 auto;display: flex;\" src=\"//player.bilibili.com/player.html?bvid=BV1fD1dYLECZ\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n\n<hr />\n\n## 关于我\n<p>\n高中开始经同学介绍接触二次元文化，但是家里直到高二快结束才装宽带，所以基本是蹭同学和亲戚家的网追番和下资源。\n<br/>\n<br/>\n由于高考结束之前没怎么接触计算机，高考分数又没有特别多选择余地，所以纯粹出于好奇<i>(甚至都算不上兴趣)</i>，选择了软件工程专业<del><i>(天知道那时候怎么想的，好险当年没选信息与计算科学这种数学类专业)</i></del>。\n<br/>\n在大学里又在同学的影响下接触了 WEB 前端、网抑云、STEAM、VR，互联网的开放和包容为我打开了信息技术的大门，<del>同时也提升了二次元浓度和加重了网瘾</del>。就像《冰菓》里描绘的那样，大学的这段时光或许是我人生中为数不多的玫瑰色生活<del>(虽然没有期望的恋爱戏码)</del>。\n<br/>\n<br/>\n之后19年毕业，大家各奔前程，我也懵懵懂懂的开始了社畜生涯，就这么按部就班的忙碌到了现在。\n<br/>\n虽然历经了三年魔幻的疫情时光，这几年世界格局也是风云变幻。\n<br/>\n但是就我自己而言，工作后的生活实在乏善可陈，完全可以用循规蹈矩来形容。\n<br/>\n唯一称得上记忆深刻的是在基金上亏了不小的一笔，之后也在工作中接触到了一些浅薄的金融知识，现在对于金融市场的态度谨慎了许多。\n<br/>\n</p>\n\n## 未来\n<p>\n很迷茫，但是不管怎样，我的故事还没有结束，我希望能让生活变好。\n</p>",
                "date": "2025-02-04T02:52:38.746Z",
                "updated": "2025-02-04T02:52:38.746Z",
                "path": "about.html",
                "comments": 1,
                "layout": "page",
                "_id": "cm6q1s4os0000f4wbc4aeh24a",
                "content": "<iframe style=\"width:748px;height:421px;margin:0 auto;display: flex;\" src=\"//player.bilibili.com/player.html?bvid=BV1fD1dYLECZ\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n\n<hr />\n\n<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>\n高中开始经同学介绍接触二次元文化，但是家里直到高二快结束才装宽带，所以基本是蹭同学和亲戚家的网追番和下资源。\n<br/>\n<br/>\n由于高考结束之前没怎么接触计算机，高考分数又没有特别多选择余地，所以纯粹出于好奇<i>(甚至都算不上兴趣)</i>，选择了软件工程专业<del><i>(天知道那时候怎么想的，好险当年没选信息与计算科学这种数学类专业)</i></del>。\n<br/>\n在大学里又在同学的影响下接触了 WEB 前端、网抑云、STEAM、VR，互联网的开放和包容为我打开了信息技术的大门，<del>同时也提升了二次元浓度和加重了网瘾</del>。就像《冰菓》里描绘的那样，大学的这段时光或许是我人生中为数不多的玫瑰色生活<del>(虽然没有期望的恋爱戏码)</del>。\n<br/>\n<br/>\n之后19年毕业，大家各奔前程，我也懵懵懂懂的开始了社畜生涯，就这么按部就班的忙碌到了现在。\n<br/>\n虽然历经了三年魔幻的疫情时光，这几年世界格局也是风云变幻。\n<br/>\n但是就我自己而言，工作后的生活实在乏善可陈，完全可以用循规蹈矩来形容。\n<br/>\n唯一称得上记忆深刻的是在基金上亏了不小的一笔，之后也在工作中接触到了一些浅薄的金融知识，现在对于金融市场的态度谨慎了许多。\n<br/>\n</p>\n\n<h2 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h2><p>\n很迷茫，但是不管怎样，我的故事还没有结束，我希望能让生活变好。\n</p>",
                "excerpt": "",
                "more": "<iframe style=\"width:748px;height:421px;margin:0 auto;display: flex;\" src=\"//player.bilibili.com/player.html?bvid=BV1fD1dYLECZ\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n\n<hr />\n\n<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>\n高中开始经同学介绍接触二次元文化，但是家里直到高二快结束才装宽带，所以基本是蹭同学和亲戚家的网追番和下资源。\n<br/>\n<br/>\n由于高考结束之前没怎么接触计算机，高考分数又没有特别多选择余地，所以纯粹出于好奇<i>(甚至都算不上兴趣)</i>，选择了软件工程专业<del><i>(天知道那时候怎么想的，好险当年没选信息与计算科学这种数学类专业)</i></del>。\n<br/>\n在大学里又在同学的影响下接触了 WEB 前端、网抑云、STEAM、VR，互联网的开放和包容为我打开了信息技术的大门，<del>同时也提升了二次元浓度和加重了网瘾</del>。就像《冰菓》里描绘的那样，大学的这段时光或许是我人生中为数不多的玫瑰色生活<del>(虽然没有期望的恋爱戏码)</del>。\n<br/>\n<br/>\n之后19年毕业，大家各奔前程，我也懵懵懂懂的开始了社畜生涯，就这么按部就班的忙碌到了现在。\n<br/>\n虽然历经了三年魔幻的疫情时光，这几年世界格局也是风云变幻。\n<br/>\n但是就我自己而言，工作后的生活实在乏善可陈，完全可以用循规蹈矩来形容。\n<br/>\n唯一称得上记忆深刻的是在基金上亏了不小的一笔，之后也在工作中接触到了一些浅薄的金融知识，现在对于金融市场的态度谨慎了许多。\n<br/>\n</p>\n\n<h2 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h2><p>\n很迷茫，但是不管怎样，我的故事还没有结束，我希望能让生活变好。\n</p>"
            },
            {
                "title": "文章归档",
                "layout": "archives",
                "_content": "",
                "source": "archive.md",
                "raw": "---\ntitle: 文章归档\nlayout: archives\n---\n",
                "date": "2024-11-17T04:13:06.812Z",
                "updated": "2024-05-31T15:58:14.000Z",
                "path": "archive.html",
                "comments": 1,
                "_id": "cm6q1s4ox0002f4wbe5az8pfa",
                "content": "",
                "excerpt": "",
                "more": ""
            },
            {
                "title": "我的朋友",
                "layout": "friends",
                "_content": "\n## 我的朋友\n",
                "source": "friends.md",
                "raw": "---\ntitle: 我的朋友\nlayout: friends\n---\n\n## 我的朋友\n",
                "date": "2025-02-03T17:30:19.335Z",
                "updated": "2025-02-03T17:30:19.335Z",
                "path": "friends.html",
                "comments": 1,
                "_id": "cm6q1s4p00006f4wba30j4iz5",
                "content": "<h2 id=\"我的朋友\"><a href=\"#我的朋友\" class=\"headerlink\" title=\"我的朋友\"></a>我的朋友</h2>",
                "excerpt": "",
                "more": "<h2 id=\"我的朋友\"><a href=\"#我的朋友\" class=\"headerlink\" title=\"我的朋友\"></a>我的朋友</h2>"
            }
        ],
        "Post": [
            {
                "title": "el-dialog在数组中的更新问题",
                "_content": "## 问题表现\n\n公司的项目还在使用 Vue 2 和 element-ui ，在实现功能时发现了一个奇怪的问题，点开弹窗后再更新列表数据，列表数据不展示了。\n\n![列表不展示](./images/el-dialog在数组中的更新问题/列表不展示.webp)\n\n## TL;DR\n\nelement-ui中ElDialog的appendToBody的实现采用了将DOM节点挂载到document.body的方式，会导致ElDialog的DOM的父节点变为document.body，而 VUE 2 在列表中插入元素时，会判断被插入的节点的父DOM节点是否与列表包裹的DOM节点一致，由于上述实现会导致新增的元素无法插入到ElDialog前，从而导致在列表更新时异常\n\n## 复现问题\n\n原项目组件比较复杂，通过几次尝试，发现通过 watch 可以看到 Vue 是监听到了数据变更的。这就有点奇怪了，如果监听到了数据变化，正常就应该渲染成对应的Dom节点，但是实际并没有，看上去似乎是在实际diff渲染时出现了问题\n\n> PS: 以下均以事后简化复现的示例进行讲解\n\n## 复现代码\n\n参考[problem-reproduction](https://github.com/jijiwuming/problem-reproduction/blob/main/src/components/list-with-dialog.vue)\n\n也可尝试[在线编辑](https://stackblitz.com/edit/vue2-problem?file=src%2Fcomponents%2Flist-with-dialog.vue)\n\n### 1. 添加断点\n\n初步判断是组件更新过程中产生异常导致的，为了查找异常更新的原因，需要添加断点，但是不能直接添加普通的断点，因为直接添加断点每次更新都会被触发，太多的断点会导致无法找到有效的信息，我们知道vue的更新时机在nextTick时，通过flushSchedulerQueue执行watcher来完成，因此可以在flushSchedulerQueue过程中的watcher.run()添加断点，并且组件的更新渲染是通过渲染watcher（RenderWatcher）来实现的，那么找到合适的RenderWatcher就变得尤为重要，由于RenderWatcher在构建时有传入特殊标识isRenderWatcher，可以看到Watcher创建对应的逻辑，\n```javascript\nthis.vm = vm;\nif (isRenderWatcher) {\n  vm._watcher = this;\n}\n// ...\nthis.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n// parse expression for getter\nif (typeof expOrFn === 'function') {\n  this.getter = expOrFn;\n}\n```\n用watcher.vm._watcher === watcher来区分 RenderWatcher,其次我们应该需要找到的是列表父元素的更新，因此需要针对该元素过滤,由于RenderWatcher.vm即为组件，因此过滤 watcher.vm.$el.className==='list-wrapper'，触发到watcher.run()的断点后，可以看到对应watcher的表达式expression如下\n```javascript\nfunction () {vm._update(vm._render(), hydrating);}\n```\n结合上文中可以知道，事实上这就是创建watcher时传入的expOrFn，而实际watcher.run执行的时候会执行watcher的getter\n```javascript\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    // ...\n  } finally {\n    // ...\n  }\n  return value\n};\n```\n可以看到实际就是执行了这个expOrFn，因此下一步需要找到_render和_update分析逻辑，由于_render主要负责完成vnode的创建，_update主要完成vnode到实际dom的patch，\n```javascript\nvm.$el = vm.__patch__(prevVnode, vnode);\n```\n因此我们将断点添加到_update入口，根据生成完的vnode来判断问题具体出现在以上2步中的哪一步，事实上这边可以看到生成的vnode中children数量是正确的，即使不愿相信，但是问题大概率出现在了生成实际dom的过程中，接下去，跟随__patchch__,可以一步步走到patch(oldVnode, vnode, hydrating, removeOnly)中的patchVnode\n```javascript\nvar isRealElement = isDef(oldVnode.nodeType);\nif (!isRealElement && sameVnode(oldVnode, vnode)) {\n  // patch existing root node\n  patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n}\n```\n进入patchVnode，接下去可以看到走入到updateChildren，在下文添加断点\n```javascript\nwhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){\n  // ...\n}\n```\n最后可以看到while循环走完后没有问题，就是完成了首部和尾部dialog的比对，正常进入了下边的逻辑\n```javascript\nif (oldStartIdx > oldEndIdx) {\n  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n}\n```\n说明此时vnode的diff更新并没有问题，但是界面上却没有出现该有的新元素，为啥呢？\n往下走，进入addVnodes函数\n```javascript\nfunction addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n  }\n}\n```\n此时的startIdx与endIdx相等，创建的正是新加入的那一项，没毛病啊，接着走入createElm，\n最终会跟着断点走入到这一行，作用是插入本次新增的组件的dom节点到指定的parentElm下的refElm前\n```javascript\n insert(parentElm, vnode.elm, refElm);\n```\n接下去来看看insert函数内部\n```javascript\nfunction insert(parent, elm, ref$$1) {\n  if (isDef(parent)) {\n    if (isDef(ref$$1)) {\n      if (nodeOps.parentNode(ref$$1) === parent) {\n        nodeOps.insertBefore(parent, elm, ref$$1);\n      }\n    } else {\n      nodeOps.appendChild(parent, elm);\n    }\n  }\n}\n```\n此时parent是列表的包裹项，ref$$1是dialog组件的dom节点，逻辑走入下面这部分\n```javascript\n// 这边nodeOps.parentNode(ref$$1)其实就是ref$$1.parentNode\n// 参考\n// function parentNode(node) {\n//   return node.parentNode\n// }\nif (nodeOps.parentNode(ref$$1) === parent) {\n  nodeOps.insertBefore(parent, elm, ref$$1);\n}\n```\n至此，真相已经浮出水面，nodeOps.parentNode(ref$$1)是什么呢?\n由于dialog设置了append-to-body，导致nodeOps.parentNode(ref$$1)对应的是body元素，\n而parent却是列表的包裹项，nodeOps.parentNode(ref$$1) === parent判断不通过，所以实际dom并没有被插入\n至此，我们已经找到了列表不更新问题的直接原因，然而，仍然有一朵乌云萦绕在我心头:为什么会在弹窗打开过后才出现这个问题呢？\n再来看element-ui中对于ElDialog的实现,找到node_modules\\element-ui\\lib\\element-ui.common.js\n搜索ElDialog看看，\n```javascript\n watch: {\n    visible: function visible(val) {\n      var _this = this;\n\n      if (val) {\n        // ....\n        if (this.appendToBody) {\n          document.body.appendChild(this.$el);\n        }\n      } else {\n        // ...\n      }\n    }\n  },\n  mounted: function mounted() {\n    if (this.visible) {\n      // ...\n      if (this.appendToBody) {\n        document.body.appendChild(this.$el);\n      }\n    }\n  },\n```\n醍醐灌顶啊兄弟们，带有appendToBody的ElDialog会被移动到到body下，但是这个操作不是一开始就操作的，而是在首次打开后才触发的\n\n牢记血泪教训：\n> 在基于前端框架的开发中，应尽量避免越过框架直接操作DOM元素",
                "source": "_posts/el-dialog在数组中的更新问题.md",
                "raw": "---\ntitle: el-dialog在数组中的更新问题\ntags: [vue 2, element-ui]\ncategories: [前端]\n---\n## 问题表现\n\n公司的项目还在使用 Vue 2 和 element-ui ，在实现功能时发现了一个奇怪的问题，点开弹窗后再更新列表数据，列表数据不展示了。\n\n![列表不展示](./images/el-dialog在数组中的更新问题/列表不展示.webp)\n\n## TL;DR\n\nelement-ui中ElDialog的appendToBody的实现采用了将DOM节点挂载到document.body的方式，会导致ElDialog的DOM的父节点变为document.body，而 VUE 2 在列表中插入元素时，会判断被插入的节点的父DOM节点是否与列表包裹的DOM节点一致，由于上述实现会导致新增的元素无法插入到ElDialog前，从而导致在列表更新时异常\n\n## 复现问题\n\n原项目组件比较复杂，通过几次尝试，发现通过 watch 可以看到 Vue 是监听到了数据变更的。这就有点奇怪了，如果监听到了数据变化，正常就应该渲染成对应的Dom节点，但是实际并没有，看上去似乎是在实际diff渲染时出现了问题\n\n> PS: 以下均以事后简化复现的示例进行讲解\n\n## 复现代码\n\n参考[problem-reproduction](https://github.com/jijiwuming/problem-reproduction/blob/main/src/components/list-with-dialog.vue)\n\n也可尝试[在线编辑](https://stackblitz.com/edit/vue2-problem?file=src%2Fcomponents%2Flist-with-dialog.vue)\n\n### 1. 添加断点\n\n初步判断是组件更新过程中产生异常导致的，为了查找异常更新的原因，需要添加断点，但是不能直接添加普通的断点，因为直接添加断点每次更新都会被触发，太多的断点会导致无法找到有效的信息，我们知道vue的更新时机在nextTick时，通过flushSchedulerQueue执行watcher来完成，因此可以在flushSchedulerQueue过程中的watcher.run()添加断点，并且组件的更新渲染是通过渲染watcher（RenderWatcher）来实现的，那么找到合适的RenderWatcher就变得尤为重要，由于RenderWatcher在构建时有传入特殊标识isRenderWatcher，可以看到Watcher创建对应的逻辑，\n```javascript\nthis.vm = vm;\nif (isRenderWatcher) {\n  vm._watcher = this;\n}\n// ...\nthis.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n// parse expression for getter\nif (typeof expOrFn === 'function') {\n  this.getter = expOrFn;\n}\n```\n用watcher.vm._watcher === watcher来区分 RenderWatcher,其次我们应该需要找到的是列表父元素的更新，因此需要针对该元素过滤,由于RenderWatcher.vm即为组件，因此过滤 watcher.vm.$el.className==='list-wrapper'，触发到watcher.run()的断点后，可以看到对应watcher的表达式expression如下\n```javascript\nfunction () {vm._update(vm._render(), hydrating);}\n```\n结合上文中可以知道，事实上这就是创建watcher时传入的expOrFn，而实际watcher.run执行的时候会执行watcher的getter\n```javascript\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    // ...\n  } finally {\n    // ...\n  }\n  return value\n};\n```\n可以看到实际就是执行了这个expOrFn，因此下一步需要找到_render和_update分析逻辑，由于_render主要负责完成vnode的创建，_update主要完成vnode到实际dom的patch，\n```javascript\nvm.$el = vm.__patch__(prevVnode, vnode);\n```\n因此我们将断点添加到_update入口，根据生成完的vnode来判断问题具体出现在以上2步中的哪一步，事实上这边可以看到生成的vnode中children数量是正确的，即使不愿相信，但是问题大概率出现在了生成实际dom的过程中，接下去，跟随__patchch__,可以一步步走到patch(oldVnode, vnode, hydrating, removeOnly)中的patchVnode\n```javascript\nvar isRealElement = isDef(oldVnode.nodeType);\nif (!isRealElement && sameVnode(oldVnode, vnode)) {\n  // patch existing root node\n  patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n}\n```\n进入patchVnode，接下去可以看到走入到updateChildren，在下文添加断点\n```javascript\nwhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){\n  // ...\n}\n```\n最后可以看到while循环走完后没有问题，就是完成了首部和尾部dialog的比对，正常进入了下边的逻辑\n```javascript\nif (oldStartIdx > oldEndIdx) {\n  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n}\n```\n说明此时vnode的diff更新并没有问题，但是界面上却没有出现该有的新元素，为啥呢？\n往下走，进入addVnodes函数\n```javascript\nfunction addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n  }\n}\n```\n此时的startIdx与endIdx相等，创建的正是新加入的那一项，没毛病啊，接着走入createElm，\n最终会跟着断点走入到这一行，作用是插入本次新增的组件的dom节点到指定的parentElm下的refElm前\n```javascript\n insert(parentElm, vnode.elm, refElm);\n```\n接下去来看看insert函数内部\n```javascript\nfunction insert(parent, elm, ref$$1) {\n  if (isDef(parent)) {\n    if (isDef(ref$$1)) {\n      if (nodeOps.parentNode(ref$$1) === parent) {\n        nodeOps.insertBefore(parent, elm, ref$$1);\n      }\n    } else {\n      nodeOps.appendChild(parent, elm);\n    }\n  }\n}\n```\n此时parent是列表的包裹项，ref$$1是dialog组件的dom节点，逻辑走入下面这部分\n```javascript\n// 这边nodeOps.parentNode(ref$$1)其实就是ref$$1.parentNode\n// 参考\n// function parentNode(node) {\n//   return node.parentNode\n// }\nif (nodeOps.parentNode(ref$$1) === parent) {\n  nodeOps.insertBefore(parent, elm, ref$$1);\n}\n```\n至此，真相已经浮出水面，nodeOps.parentNode(ref$$1)是什么呢?\n由于dialog设置了append-to-body，导致nodeOps.parentNode(ref$$1)对应的是body元素，\n而parent却是列表的包裹项，nodeOps.parentNode(ref$$1) === parent判断不通过，所以实际dom并没有被插入\n至此，我们已经找到了列表不更新问题的直接原因，然而，仍然有一朵乌云萦绕在我心头:为什么会在弹窗打开过后才出现这个问题呢？\n再来看element-ui中对于ElDialog的实现,找到node_modules\\element-ui\\lib\\element-ui.common.js\n搜索ElDialog看看，\n```javascript\n watch: {\n    visible: function visible(val) {\n      var _this = this;\n\n      if (val) {\n        // ....\n        if (this.appendToBody) {\n          document.body.appendChild(this.$el);\n        }\n      } else {\n        // ...\n      }\n    }\n  },\n  mounted: function mounted() {\n    if (this.visible) {\n      // ...\n      if (this.appendToBody) {\n        document.body.appendChild(this.$el);\n      }\n    }\n  },\n```\n醍醐灌顶啊兄弟们，带有appendToBody的ElDialog会被移动到到body下，但是这个操作不是一开始就操作的，而是在首次打开后才触发的\n\n牢记血泪教训：\n> 在基于前端框架的开发中，应尽量避免越过框架直接操作DOM元素",
                "slug": "el-dialog在数组中的更新问题",
                "published": 1,
                "date": "2024-11-23T07:15:56.102Z",
                "updated": "2025-02-04T06:32:28.572Z",
                "_id": "cm6q1s4ov0001f4wbchyn0bz8",
                "comments": 1,
                "layout": "post",
                "photos": [],
                "content": "<h2 id=\"问题表现\"><a href=\"#问题表现\" class=\"headerlink\" title=\"问题表现\"></a>问题表现</h2><p>公司的项目还在使用 Vue 2 和 element-ui ，在实现功能时发现了一个奇怪的问题，点开弹窗后再更新列表数据，列表数据不展示了。</p>\n<p><img src=\"/./images/el-dialog%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/%E5%88%97%E8%A1%A8%E4%B8%8D%E5%B1%95%E7%A4%BA.webp\" alt=\"列表不展示\"></p>\n<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>element-ui中ElDialog的appendToBody的实现采用了将DOM节点挂载到document.body的方式，会导致ElDialog的DOM的父节点变为document.body，而 VUE 2 在列表中插入元素时，会判断被插入的节点的父DOM节点是否与列表包裹的DOM节点一致，由于上述实现会导致新增的元素无法插入到ElDialog前，从而导致在列表更新时异常</p>\n<h2 id=\"复现问题\"><a href=\"#复现问题\" class=\"headerlink\" title=\"复现问题\"></a>复现问题</h2><p>原项目组件比较复杂，通过几次尝试，发现通过 watch 可以看到 Vue 是监听到了数据变更的。这就有点奇怪了，如果监听到了数据变化，正常就应该渲染成对应的Dom节点，但是实际并没有，看上去似乎是在实际diff渲染时出现了问题</p>\n<blockquote>\n<p>PS: 以下均以事后简化复现的示例进行讲解</p>\n</blockquote>\n<h2 id=\"复现代码\"><a href=\"#复现代码\" class=\"headerlink\" title=\"复现代码\"></a>复现代码</h2><p>参考<a href=\"https://github.com/jijiwuming/problem-reproduction/blob/main/src/components/list-with-dialog.vue\">problem-reproduction</a></p>\n<p>也可尝试<a href=\"https://stackblitz.com/edit/vue2-problem?file=src/components/list-with-dialog.vue\">在线编辑</a></p>\n<h3 id=\"1-添加断点\"><a href=\"#1-添加断点\" class=\"headerlink\" title=\"1. 添加断点\"></a>1. 添加断点</h3><p>初步判断是组件更新过程中产生异常导致的，为了查找异常更新的原因，需要添加断点，但是不能直接添加普通的断点，因为直接添加断点每次更新都会被触发，太多的断点会导致无法找到有效的信息，我们知道vue的更新时机在nextTick时，通过flushSchedulerQueue执行watcher来完成，因此可以在flushSchedulerQueue过程中的watcher.run()添加断点，并且组件的更新渲染是通过渲染watcher（RenderWatcher）来实现的，那么找到合适的RenderWatcher就变得尤为重要，由于RenderWatcher在构建时有传入特殊标识isRenderWatcher，可以看到Watcher创建对应的逻辑，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span> = vm;<br><span class=\"hljs-keyword\">if</span> (isRenderWatcher) &#123;<br>  vm.<span class=\"hljs-property\">_watcher</span> = <span class=\"hljs-variable language_\">this</span>;<br>&#125;<br><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">expression</span> = process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">NODE_ENV</span> !== <span class=\"hljs-string\">&#x27;production&#x27;</span><br>    ? expOrFn.<span class=\"hljs-title function_\">toString</span>()<br>    : <span class=\"hljs-string\">&#x27;&#x27;</span>;<br><span class=\"hljs-comment\">// parse expression for getter</span><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> expOrFn === <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">getter</span> = expOrFn;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>用watcher.vm._watcher &#x3D;&#x3D;&#x3D; watcher来区分 RenderWatcher,其次我们应该需要找到的是列表父元素的更新，因此需要针对该元素过滤,由于RenderWatcher.vm即为组件，因此过滤 watcher.vm.$el.className&#x3D;&#x3D;&#x3D;’list-wrapper’，触发到watcher.run()的断点后，可以看到对应watcher的表达式expression如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;vm.<span class=\"hljs-title function_\">_update</span>(vm.<span class=\"hljs-title function_\">_render</span>(), hydrating);&#125;<br></code></pre></td></tr></table></figure>\n<p>结合上文中可以知道，事实上这就是创建watcher时传入的expOrFn，而实际watcher.run执行的时候会执行watcher的getter</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Watcher</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">get</span> = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-title function_\">pushTarget</span>(<span class=\"hljs-variable language_\">this</span>);<br>  <span class=\"hljs-keyword\">var</span> value;<br>  <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span>;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">getter</span>.<span class=\"hljs-title function_\">call</span>(vm, vm);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>  &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> value<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以看到实际就是执行了这个expOrFn，因此下一步需要找到_render和_update分析逻辑，由于_render主要负责完成vnode的创建，_update主要完成vnode到实际dom的patch，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">vm.<span class=\"hljs-property\">$el</span> = vm.<span class=\"hljs-title function_\">__patch__</span>(prevVnode, vnode);<br></code></pre></td></tr></table></figure>\n<p>因此我们将断点添加到_update入口，根据生成完的vnode来判断问题具体出现在以上2步中的哪一步，事实上这边可以看到生成的vnode中children数量是正确的，即使不愿相信，但是问题大概率出现在了生成实际dom的过程中，接下去，跟随__patchch__,可以一步步走到patch(oldVnode, vnode, hydrating, removeOnly)中的patchVnode</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> isRealElement = <span class=\"hljs-title function_\">isDef</span>(oldVnode.<span class=\"hljs-property\">nodeType</span>);<br><span class=\"hljs-keyword\">if</span> (!isRealElement &amp;&amp; <span class=\"hljs-title function_\">sameVnode</span>(oldVnode, vnode)) &#123;<br>  <span class=\"hljs-comment\">// patch existing root node</span><br>  <span class=\"hljs-title function_\">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, removeOnly);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>进入patchVnode，接下去可以看到走入到updateChildren，在下文添加断点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx)&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>最后可以看到while循环走完后没有问题，就是完成了首部和尾部dialog的比对，正常进入了下边的逻辑</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>  refElm = <span class=\"hljs-title function_\">isUndef</span>(newCh[newEndIdx + <span class=\"hljs-number\">1</span>]) ? <span class=\"hljs-literal\">null</span> : newCh[newEndIdx + <span class=\"hljs-number\">1</span>].<span class=\"hljs-property\">elm</span>;<br>  <span class=\"hljs-title function_\">addVnodes</span>(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>说明此时vnode的diff更新并没有问题，但是界面上却没有出现该有的新元素，为啥呢？<br>往下走，进入addVnodes函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addVnodes</span>(<span class=\"hljs-params\">parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue</span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;<br>    <span class=\"hljs-title function_\">createElm</span>(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, <span class=\"hljs-literal\">false</span>, vnodes, startIdx);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>此时的startIdx与endIdx相等，创建的正是新加入的那一项，没毛病啊，接着走入createElm，<br>最终会跟着断点走入到这一行，作用是插入本次新增的组件的dom节点到指定的parentElm下的refElm前</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">insert</span>(parentElm, vnode.<span class=\"hljs-property\">elm</span>, refElm);<br></code></pre></td></tr></table></figure>\n<p>接下去来看看insert函数内部</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">insert</span>(<span class=\"hljs-params\">parent, elm, ref$$1</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isDef</span>(parent)) &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isDef</span>(ref$$1)) &#123;<br>      <span class=\"hljs-keyword\">if</span> (nodeOps.<span class=\"hljs-title function_\">parentNode</span>(ref$$1) === parent) &#123;<br>        nodeOps.<span class=\"hljs-title function_\">insertBefore</span>(parent, elm, ref$$1);<br>      &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      nodeOps.<span class=\"hljs-title function_\">appendChild</span>(parent, elm);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>此时parent是列表的包裹项，ref$$1是dialog组件的dom节点，逻辑走入下面这部分</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 这边nodeOps.parentNode(ref$$1)其实就是ref$$1.parentNode</span><br><span class=\"hljs-comment\">// 参考</span><br><span class=\"hljs-comment\">// function parentNode(node) &#123;</span><br><span class=\"hljs-comment\">//   return node.parentNode</span><br><span class=\"hljs-comment\">// &#125;</span><br><span class=\"hljs-keyword\">if</span> (nodeOps.<span class=\"hljs-title function_\">parentNode</span>(ref$$1) === parent) &#123;<br>  nodeOps.<span class=\"hljs-title function_\">insertBefore</span>(parent, elm, ref$$1);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>至此，真相已经浮出水面，nodeOps.parentNode(ref$$1)是什么呢?<br>由于dialog设置了append-to-body，导致nodeOps.parentNode(ref$$1)对应的是body元素，<br>而parent却是列表的包裹项，nodeOps.parentNode(ref$$1) &#x3D;&#x3D;&#x3D; parent判断不通过，所以实际dom并没有被插入<br>至此，我们已经找到了列表不更新问题的直接原因，然而，仍然有一朵乌云萦绕在我心头:为什么会在弹窗打开过后才出现这个问题呢？<br>再来看element-ui中对于ElDialog的实现,找到node_modules\\element-ui\\lib\\element-ui.common.js<br>搜索ElDialog看看，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">watch</span>: &#123;<br>   <span class=\"hljs-attr\">visible</span>: <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">visible</span>(<span class=\"hljs-params\">val</span>) &#123;<br>     <span class=\"hljs-keyword\">var</span> _this = <span class=\"hljs-variable language_\">this</span>;<br><br>     <span class=\"hljs-keyword\">if</span> (val) &#123;<br>       <span class=\"hljs-comment\">// ....</span><br>       <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">appendToBody</span>) &#123;<br>         <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span>);<br>       &#125;<br>     &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>       <span class=\"hljs-comment\">// ...</span><br>     &#125;<br>   &#125;<br> &#125;,<br> <span class=\"hljs-attr\">mounted</span>: <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mounted</span>(<span class=\"hljs-params\"></span>) &#123;<br>   <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">visible</span>) &#123;<br>     <span class=\"hljs-comment\">// ...</span><br>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">appendToBody</span>) &#123;<br>       <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span>);<br>     &#125;<br>   &#125;<br> &#125;,<br></code></pre></td></tr></table></figure>\n<p>醍醐灌顶啊兄弟们，带有appendToBody的ElDialog会被移动到到body下，但是这个操作不是一开始就操作的，而是在首次打开后才触发的</p>\n<p>牢记血泪教训：</p>\n<blockquote>\n<p>在基于前端框架的开发中，应尽量避免越过框架直接操作DOM元素</p>\n</blockquote>\n",
                "excerpt": "",
                "more": "<h2 id=\"问题表现\"><a href=\"#问题表现\" class=\"headerlink\" title=\"问题表现\"></a>问题表现</h2><p>公司的项目还在使用 Vue 2 和 element-ui ，在实现功能时发现了一个奇怪的问题，点开弹窗后再更新列表数据，列表数据不展示了。</p>\n<p><img src=\"/./images/el-dialog%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/%E5%88%97%E8%A1%A8%E4%B8%8D%E5%B1%95%E7%A4%BA.webp\" alt=\"列表不展示\"></p>\n<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>element-ui中ElDialog的appendToBody的实现采用了将DOM节点挂载到document.body的方式，会导致ElDialog的DOM的父节点变为document.body，而 VUE 2 在列表中插入元素时，会判断被插入的节点的父DOM节点是否与列表包裹的DOM节点一致，由于上述实现会导致新增的元素无法插入到ElDialog前，从而导致在列表更新时异常</p>\n<h2 id=\"复现问题\"><a href=\"#复现问题\" class=\"headerlink\" title=\"复现问题\"></a>复现问题</h2><p>原项目组件比较复杂，通过几次尝试，发现通过 watch 可以看到 Vue 是监听到了数据变更的。这就有点奇怪了，如果监听到了数据变化，正常就应该渲染成对应的Dom节点，但是实际并没有，看上去似乎是在实际diff渲染时出现了问题</p>\n<blockquote>\n<p>PS: 以下均以事后简化复现的示例进行讲解</p>\n</blockquote>\n<h2 id=\"复现代码\"><a href=\"#复现代码\" class=\"headerlink\" title=\"复现代码\"></a>复现代码</h2><p>参考<a href=\"https://github.com/jijiwuming/problem-reproduction/blob/main/src/components/list-with-dialog.vue\">problem-reproduction</a></p>\n<p>也可尝试<a href=\"https://stackblitz.com/edit/vue2-problem?file=src/components/list-with-dialog.vue\">在线编辑</a></p>\n<h3 id=\"1-添加断点\"><a href=\"#1-添加断点\" class=\"headerlink\" title=\"1. 添加断点\"></a>1. 添加断点</h3><p>初步判断是组件更新过程中产生异常导致的，为了查找异常更新的原因，需要添加断点，但是不能直接添加普通的断点，因为直接添加断点每次更新都会被触发，太多的断点会导致无法找到有效的信息，我们知道vue的更新时机在nextTick时，通过flushSchedulerQueue执行watcher来完成，因此可以在flushSchedulerQueue过程中的watcher.run()添加断点，并且组件的更新渲染是通过渲染watcher（RenderWatcher）来实现的，那么找到合适的RenderWatcher就变得尤为重要，由于RenderWatcher在构建时有传入特殊标识isRenderWatcher，可以看到Watcher创建对应的逻辑，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span> = vm;<br><span class=\"hljs-keyword\">if</span> (isRenderWatcher) &#123;<br>  vm.<span class=\"hljs-property\">_watcher</span> = <span class=\"hljs-variable language_\">this</span>;<br>&#125;<br><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">expression</span> = process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">NODE_ENV</span> !== <span class=\"hljs-string\">&#x27;production&#x27;</span><br>    ? expOrFn.<span class=\"hljs-title function_\">toString</span>()<br>    : <span class=\"hljs-string\">&#x27;&#x27;</span>;<br><span class=\"hljs-comment\">// parse expression for getter</span><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> expOrFn === <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">getter</span> = expOrFn;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>用watcher.vm._watcher &#x3D;&#x3D;&#x3D; watcher来区分 RenderWatcher,其次我们应该需要找到的是列表父元素的更新，因此需要针对该元素过滤,由于RenderWatcher.vm即为组件，因此过滤 watcher.vm.$el.className&#x3D;&#x3D;&#x3D;’list-wrapper’，触发到watcher.run()的断点后，可以看到对应watcher的表达式expression如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;vm.<span class=\"hljs-title function_\">_update</span>(vm.<span class=\"hljs-title function_\">_render</span>(), hydrating);&#125;<br></code></pre></td></tr></table></figure>\n<p>结合上文中可以知道，事实上这就是创建watcher时传入的expOrFn，而实际watcher.run执行的时候会执行watcher的getter</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Watcher</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">get</span> = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-title function_\">pushTarget</span>(<span class=\"hljs-variable language_\">this</span>);<br>  <span class=\"hljs-keyword\">var</span> value;<br>  <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span>;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">getter</span>.<span class=\"hljs-title function_\">call</span>(vm, vm);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>  &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> value<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以看到实际就是执行了这个expOrFn，因此下一步需要找到_render和_update分析逻辑，由于_render主要负责完成vnode的创建，_update主要完成vnode到实际dom的patch，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">vm.<span class=\"hljs-property\">$el</span> = vm.<span class=\"hljs-title function_\">__patch__</span>(prevVnode, vnode);<br></code></pre></td></tr></table></figure>\n<p>因此我们将断点添加到_update入口，根据生成完的vnode来判断问题具体出现在以上2步中的哪一步，事实上这边可以看到生成的vnode中children数量是正确的，即使不愿相信，但是问题大概率出现在了生成实际dom的过程中，接下去，跟随__patchch__,可以一步步走到patch(oldVnode, vnode, hydrating, removeOnly)中的patchVnode</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> isRealElement = <span class=\"hljs-title function_\">isDef</span>(oldVnode.<span class=\"hljs-property\">nodeType</span>);<br><span class=\"hljs-keyword\">if</span> (!isRealElement &amp;&amp; <span class=\"hljs-title function_\">sameVnode</span>(oldVnode, vnode)) &#123;<br>  <span class=\"hljs-comment\">// patch existing root node</span><br>  <span class=\"hljs-title function_\">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, removeOnly);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>进入patchVnode，接下去可以看到走入到updateChildren，在下文添加断点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx)&#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>最后可以看到while循环走完后没有问题，就是完成了首部和尾部dialog的比对，正常进入了下边的逻辑</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>  refElm = <span class=\"hljs-title function_\">isUndef</span>(newCh[newEndIdx + <span class=\"hljs-number\">1</span>]) ? <span class=\"hljs-literal\">null</span> : newCh[newEndIdx + <span class=\"hljs-number\">1</span>].<span class=\"hljs-property\">elm</span>;<br>  <span class=\"hljs-title function_\">addVnodes</span>(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>说明此时vnode的diff更新并没有问题，但是界面上却没有出现该有的新元素，为啥呢？<br>往下走，进入addVnodes函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addVnodes</span>(<span class=\"hljs-params\">parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue</span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;<br>    <span class=\"hljs-title function_\">createElm</span>(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, <span class=\"hljs-literal\">false</span>, vnodes, startIdx);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>此时的startIdx与endIdx相等，创建的正是新加入的那一项，没毛病啊，接着走入createElm，<br>最终会跟着断点走入到这一行，作用是插入本次新增的组件的dom节点到指定的parentElm下的refElm前</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">insert</span>(parentElm, vnode.<span class=\"hljs-property\">elm</span>, refElm);<br></code></pre></td></tr></table></figure>\n<p>接下去来看看insert函数内部</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">insert</span>(<span class=\"hljs-params\">parent, elm, ref$$1</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isDef</span>(parent)) &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isDef</span>(ref$$1)) &#123;<br>      <span class=\"hljs-keyword\">if</span> (nodeOps.<span class=\"hljs-title function_\">parentNode</span>(ref$$1) === parent) &#123;<br>        nodeOps.<span class=\"hljs-title function_\">insertBefore</span>(parent, elm, ref$$1);<br>      &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      nodeOps.<span class=\"hljs-title function_\">appendChild</span>(parent, elm);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>此时parent是列表的包裹项，ref$$1是dialog组件的dom节点，逻辑走入下面这部分</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 这边nodeOps.parentNode(ref$$1)其实就是ref$$1.parentNode</span><br><span class=\"hljs-comment\">// 参考</span><br><span class=\"hljs-comment\">// function parentNode(node) &#123;</span><br><span class=\"hljs-comment\">//   return node.parentNode</span><br><span class=\"hljs-comment\">// &#125;</span><br><span class=\"hljs-keyword\">if</span> (nodeOps.<span class=\"hljs-title function_\">parentNode</span>(ref$$1) === parent) &#123;<br>  nodeOps.<span class=\"hljs-title function_\">insertBefore</span>(parent, elm, ref$$1);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>至此，真相已经浮出水面，nodeOps.parentNode(ref$$1)是什么呢?<br>由于dialog设置了append-to-body，导致nodeOps.parentNode(ref$$1)对应的是body元素，<br>而parent却是列表的包裹项，nodeOps.parentNode(ref$$1) &#x3D;&#x3D;&#x3D; parent判断不通过，所以实际dom并没有被插入<br>至此，我们已经找到了列表不更新问题的直接原因，然而，仍然有一朵乌云萦绕在我心头:为什么会在弹窗打开过后才出现这个问题呢？<br>再来看element-ui中对于ElDialog的实现,找到node_modules\\element-ui\\lib\\element-ui.common.js<br>搜索ElDialog看看，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">watch</span>: &#123;<br>   <span class=\"hljs-attr\">visible</span>: <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">visible</span>(<span class=\"hljs-params\">val</span>) &#123;<br>     <span class=\"hljs-keyword\">var</span> _this = <span class=\"hljs-variable language_\">this</span>;<br><br>     <span class=\"hljs-keyword\">if</span> (val) &#123;<br>       <span class=\"hljs-comment\">// ....</span><br>       <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">appendToBody</span>) &#123;<br>         <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span>);<br>       &#125;<br>     &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>       <span class=\"hljs-comment\">// ...</span><br>     &#125;<br>   &#125;<br> &#125;,<br> <span class=\"hljs-attr\">mounted</span>: <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mounted</span>(<span class=\"hljs-params\"></span>) &#123;<br>   <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">visible</span>) &#123;<br>     <span class=\"hljs-comment\">// ...</span><br>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">appendToBody</span>) &#123;<br>       <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span>);<br>     &#125;<br>   &#125;<br> &#125;,<br></code></pre></td></tr></table></figure>\n<p>醍醐灌顶啊兄弟们，带有appendToBody的ElDialog会被移动到到body下，但是这个操作不是一开始就操作的，而是在首次打开后才触发的</p>\n<p>牢记血泪教训：</p>\n<blockquote>\n<p>在基于前端框架的开发中，应尽量避免越过框架直接操作DOM元素</p>\n</blockquote>\n"
            },
            {
                "title": "el-table-column设置fixed的影响",
                "cover": "https://th.bing.com/th/id/OIP.IXOC4xuxXLQGvzTWKxJgdAHaGF",
                "_content": "## 背景描述\n\n这几天在维护Vue2项目时产生了一个bug，表现为表格中的popover组件弹出后通过$refs去获取子组件操作属性突然失效了。\n由于一开始只从展示效果上看到这个问题，控制台没有报错。所以一开始还陷入了误判，刚开始认为是某些改动导致相关属性失去了响应性。但是翻阅了下自己的代码，调整了一部分代码后，发现问题并没有解决，而且感觉代码确实也没啥问题，一下子尬住了。\n\n### Environment\n\n{\n  \"element-ui\": \"^2.13.0\",\n  \"vue\": \"^2.6.10\"\n}\n## TL;DR;\nElement-UI在实现Fixed效果的手段为：针对有Column设置Fixed的ElTable会重复渲染table的body部分，然后重叠body来实现定位效果。\n而重复渲染table-body会导致表格体内的子元素被多次渲染，而多次渲染会导致$refs被覆盖为最后创建的一个。\n不幸的是，最后创建的table-body是为fixed=\"right\"特别构建的部分，虽然也<b style=\"color:red;\">渲染了整个表格</b>，但是<b style=\"color:red;\">仅展示右侧固定列部分</b>。这种情况下，通过$refs获取到的子组件就是在这个区域内的，但是，如果你想操作的恰好是左侧非固定列的部分，不好意思，bug来了，你拿到的只是一个看不到的元素。\n所以出现这种问题的时候，比较快的解决方法是去除ElTable上所有column的fixed属性设置，如果想看具体原因和解决方案，还烦请您耐心看下文章后半部分。\n\n## 复现代码\n\n参考[problem-reproduction](https://github.com/jijiwuming/problem-reproduction/blob/main/src/components/table.vue)\n\n也可尝试[在线编辑](https://stackblitz.com/edit/vue2-problem?file=src%2Fcomponents%2Ftable.vue)\n\n## 问题定位\n\n由于这部分可以确认之前是正常的，但是具体出现问题的时间节点暂不明确，无奈，尝试了几个早期版本的镜像，希望能快速找到上一个正常的时间节点，对比代码差异来找原因。\n好在运气不错，出问题的时间并不长，从镜像看恰好是一周前，与当前比只差了5个提交。\n得，Code Review吧，然而，看了一圈：我寻思我也妹写啥相关的代码啊？\n啧，改回去试试，很快啊，本地代码就起起来了，回退了几处看上去勉强相关的，不出所料，确实没相关。\n这不就艹了么这，那就再试试没那么相关的，好家伙，到了发现是另一个el-table-column上设置fixed=\"right\"就会有这个问题\n我：地铁老人手机.jpg，不是，这又怎么着了嘛，这都不是table-column，这怎么挨上的啊？\n当然，到了这一步，快速修复方案已经有了，就是把fixed=\"right\"去掉，因此先急忙打了个补丁把线上问题糊上了\n连一刻也没有为线上bug哀悼，下一刻赶到战场的是ElTable的源码实现\n\n## 问题原因\n\n打开node_modules\\element-ui\\packages\\table\\src, 来看看是怎么个事吧\n\n### ElTableColumn（src\\table-column.js）\n先来看 ElTableColumn ，可以在created看到fixed在传入后会被设置到this.columnConfig上，并且在registerComplexWatchers设置变化监听，不过由于我代码中是直接赋固定值的，因此只需关注this.columnConfig后续在mounted中被用于owner.store.commit('insertColumn')就行。\n\n### ElTable——Store（src\\store\\index.js）\n上面的store其实在src的store下，实际就是用Vue.extend扩展出了一个Vue实例，起一个状态管理和追踪作用，可以看到insertColumn最终会执行到\n```javascript\nif (this.table.$ready) { // 这边会在ElTable完成mounted后执行，所以第一轮加载时不会有fixed部分的渲染\n  this.updateColumns(); // hack for dynamics insert column\n  this.scheduleLayout();\n}\n```\n这边主要关注的还是updateColumns，在src\\store\\watcher.js中，\n```javascript\nupdateColumns() {\n  // 省略部分代码...\n  states.fixedColumns = _columns.filter((column) => column.fixed === true || column.fixed === 'left');\n  states.rightFixedColumns = _columns.filter((column) => column.fixed === 'right');\n  // 省略部分代码...\n}\n```\n这边能看到针对fixed的列会分别被分成fixedColumns和rightFixedColumns，\n接下去再来看看ElTable中针对这些列数据的渲染，\n\n### ElTable（src\\table.vue）\n可以在这边看到computed中设置了映射\n```javascript\n...mapStates({\n  selection: 'selection',\n  columns: 'columns',\n  tableData: 'data',\n  fixedColumns: 'fixedColumns',\n  rightFixedColumns: 'rightFixedColumns'\n})\n```\n然后在template中渲染时，默认会渲染一个<table-body\\>,但是存在fixedColumns和rightFixedColumns时，分别都会增加一个<table-body\\>的渲染\n\n### ElTableBody（src\\table-body.js）\n而在ElTableBody中，实际使用render函数来渲染了全量数据，这几次的渲染不同只在与根据fixed传入把对应的列隐藏，\n其中渲染的关键部分为wrappedRowRender函数，\n```javascript\ndata.reduce((acc, row) => {\n  return acc.concat(this.wrappedRowRender(row, acc.length));\n}, [])\n```\n追踪wrappedRowRender，进一步到rowRender函数中，可以看到最终是渲染了表格的一行tr，\n而每个单元格cell的渲染则是通过column.renderCell渲染，这个值从哪来呢？\n答案是我们开始追踪的 ElTableColumn（src\\table-column.js） 中的setColumnRenders，\n主要部分如下：\n```javascript\ncolumn.renderCell = (h, data) => {\n  let children = null;\n  if (this.$scopedSlots.default) {\n    // NOTE：我们主要关注的是这个路径\n    children = this.$scopedSlots.default(data);\n  } else {\n    children = originRenderCell(h, data);\n  }\n  const prefix = treeCellPrefix(h, data);\n  const props = {\n    class: 'cell',\n    style: {}\n  };\n  if (column.showOverflowTooltip) {\n    props.class += ' el-tooltip';\n    props.style = {width: (data.column.realWidth || data.column.width) - 1 + 'px'};\n  }\n  return (<div { ...props }>\n    { prefix }\n    { children }\n  </div>);\n};\n```\n可以看到，事实上单元格内渲染的是作用域插槽$scopedSlots中的内容，\n因此综合前文逻辑，可以得出其实我们写在el-table-column中的内容会被渲染多次，\n再看看我们代码中的逻辑\n```html\n<el-popover\n  :ref=\"'custom-popover'+scope.row.uuid\"\n  placement=\"top\"\n  @show=\"showChart(scope.row.uuid)\"\n>\n  <child-chart :ref=\"'childChart'+scope.row.uuid\" />\n  <i slot=\"reference\" class=\"el-icon-question\"></i>\n</el-popover>\n```\n```javascript\nshowChart(id) {\n  const attr = 'childChart' + id;\n  const popperAttr = 'custom-popover' + id;\n  if (this.$refs && this.$refs[attr]) {\n    this.$refs[attr].showChart().then(() => {\n      this.$refs[popperAttr] && this.$refs[popperAttr].updatePopper();\n    });\n  }\n}\n```\n结合vue中registerRef的实现\n```javascript\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  // 省略部分代码...\n  if (vnode.data.refInFor) {\n    if (!Array.isArray(refs[key])) {\n      refs[key] = [ref];\n    } else if (refs[key].indexOf(ref) < 0) {\n      // $flow-disable-line\n      refs[key].push(ref);\n    }\n  } else {\n    // NOTE：这里是实际走的逻辑\n    refs[key] = ref;\n  }\n  // 省略部分代码...\n}\n```\n由于我们的代码不在v-for中，实际采用的是refs[key] = ref，\n因此后一次渲染时，会把之前的refs[key]覆盖掉，\n导致最终refs[key]指向的是最后一次数据的组件实例。\n\n## 修复方案\n\n由于会多次渲染，所以可以增加一个自增的属性，从而区分不同的子组件实例，\n但是需要注意的是这边并不是第一次生成的实例就是需要的实例，\n因为组件在初始实例化时会有多次更新的情况，初始创建的实例可能会变成空，\n\n```javascript\n// Vue的源码中\nVue.extend = function (extendOptions) {\n    // 省略部分代码...\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    // 省略部分代码...\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    // 省略部分代码...\n};\n```\n找到mergeOptions\n```javascript\n  \nfunction mergeOptions(\n  parent,\n  child,\n  vm\n) {\n  // 省略部分代码...\n  normalizeProps(child, vm);\n  // 省略部分代码...\n}\n```\n找到normalizeProps\n```javascript\nfunction normalizeProps (options, vm) {\n  // 省略部分代码...\n  options.props = res; // 这边赋值会触发新的更新\n}\n```\n因此推荐是获取第一次生成的有内容的实例,修改的主要代码如下\n```javascript\n// 用于每次渲染生成不同id\ngenId(type, uuid) {\n    const key = `${type}-${uuid}`;\n    const val = this.idMap.get(key) || 1;\n    this.idMap.set(key, val + 1);\n    return `${key}-${val}`;\n},\nshowChart(id) {\n    // NOTE：\n    // ElTable中设置了带fixed的column时，会导致table-body渲染多次（这个是UI库的实现逻辑导致的）\n    // 重复渲染会导致表格body中的子组件被多次实例化\n    // 前面genId做自增id，这边取id最小的有内容的ref就是为了解决这个问题\n    // 需要注意的是如果要获取的子组件位于fixed的column中，那么需要取的实例的id会变化，需要按具体情况分析\n    const attr = `childChart-${id}-`;\n    const popperAttr = `custom-popover-${id}-`;\n    for (let name in this.$refs) {\n        if (name.startsWith(attr) && this.$refs[name]) {\n            const popperName = popperAttr + name.replace(attr, '');\n            const item = this.$refs[name];\n            item.showChart().then(() => {\n                this.$refs[popperName] && this.$refs[popperName].updatePopper();\n            });\n        }\n    }\n}\n```\n",
                "source": "_posts/el-table-column设置fixed的影响.md",
                "raw": "---\ntitle: el-table-column设置fixed的影响\ntags: [vue 2, element-ui]\ncategories: [前端]\ncover: https://th.bing.com/th/id/OIP.IXOC4xuxXLQGvzTWKxJgdAHaGF\n---\n## 背景描述\n\n这几天在维护Vue2项目时产生了一个bug，表现为表格中的popover组件弹出后通过$refs去获取子组件操作属性突然失效了。\n由于一开始只从展示效果上看到这个问题，控制台没有报错。所以一开始还陷入了误判，刚开始认为是某些改动导致相关属性失去了响应性。但是翻阅了下自己的代码，调整了一部分代码后，发现问题并没有解决，而且感觉代码确实也没啥问题，一下子尬住了。\n\n### Environment\n\n{\n  \"element-ui\": \"^2.13.0\",\n  \"vue\": \"^2.6.10\"\n}\n## TL;DR;\nElement-UI在实现Fixed效果的手段为：针对有Column设置Fixed的ElTable会重复渲染table的body部分，然后重叠body来实现定位效果。\n而重复渲染table-body会导致表格体内的子元素被多次渲染，而多次渲染会导致$refs被覆盖为最后创建的一个。\n不幸的是，最后创建的table-body是为fixed=\"right\"特别构建的部分，虽然也<b style=\"color:red;\">渲染了整个表格</b>，但是<b style=\"color:red;\">仅展示右侧固定列部分</b>。这种情况下，通过$refs获取到的子组件就是在这个区域内的，但是，如果你想操作的恰好是左侧非固定列的部分，不好意思，bug来了，你拿到的只是一个看不到的元素。\n所以出现这种问题的时候，比较快的解决方法是去除ElTable上所有column的fixed属性设置，如果想看具体原因和解决方案，还烦请您耐心看下文章后半部分。\n\n## 复现代码\n\n参考[problem-reproduction](https://github.com/jijiwuming/problem-reproduction/blob/main/src/components/table.vue)\n\n也可尝试[在线编辑](https://stackblitz.com/edit/vue2-problem?file=src%2Fcomponents%2Ftable.vue)\n\n## 问题定位\n\n由于这部分可以确认之前是正常的，但是具体出现问题的时间节点暂不明确，无奈，尝试了几个早期版本的镜像，希望能快速找到上一个正常的时间节点，对比代码差异来找原因。\n好在运气不错，出问题的时间并不长，从镜像看恰好是一周前，与当前比只差了5个提交。\n得，Code Review吧，然而，看了一圈：我寻思我也妹写啥相关的代码啊？\n啧，改回去试试，很快啊，本地代码就起起来了，回退了几处看上去勉强相关的，不出所料，确实没相关。\n这不就艹了么这，那就再试试没那么相关的，好家伙，到了发现是另一个el-table-column上设置fixed=\"right\"就会有这个问题\n我：地铁老人手机.jpg，不是，这又怎么着了嘛，这都不是table-column，这怎么挨上的啊？\n当然，到了这一步，快速修复方案已经有了，就是把fixed=\"right\"去掉，因此先急忙打了个补丁把线上问题糊上了\n连一刻也没有为线上bug哀悼，下一刻赶到战场的是ElTable的源码实现\n\n## 问题原因\n\n打开node_modules\\element-ui\\packages\\table\\src, 来看看是怎么个事吧\n\n### ElTableColumn（src\\table-column.js）\n先来看 ElTableColumn ，可以在created看到fixed在传入后会被设置到this.columnConfig上，并且在registerComplexWatchers设置变化监听，不过由于我代码中是直接赋固定值的，因此只需关注this.columnConfig后续在mounted中被用于owner.store.commit('insertColumn')就行。\n\n### ElTable——Store（src\\store\\index.js）\n上面的store其实在src的store下，实际就是用Vue.extend扩展出了一个Vue实例，起一个状态管理和追踪作用，可以看到insertColumn最终会执行到\n```javascript\nif (this.table.$ready) { // 这边会在ElTable完成mounted后执行，所以第一轮加载时不会有fixed部分的渲染\n  this.updateColumns(); // hack for dynamics insert column\n  this.scheduleLayout();\n}\n```\n这边主要关注的还是updateColumns，在src\\store\\watcher.js中，\n```javascript\nupdateColumns() {\n  // 省略部分代码...\n  states.fixedColumns = _columns.filter((column) => column.fixed === true || column.fixed === 'left');\n  states.rightFixedColumns = _columns.filter((column) => column.fixed === 'right');\n  // 省略部分代码...\n}\n```\n这边能看到针对fixed的列会分别被分成fixedColumns和rightFixedColumns，\n接下去再来看看ElTable中针对这些列数据的渲染，\n\n### ElTable（src\\table.vue）\n可以在这边看到computed中设置了映射\n```javascript\n...mapStates({\n  selection: 'selection',\n  columns: 'columns',\n  tableData: 'data',\n  fixedColumns: 'fixedColumns',\n  rightFixedColumns: 'rightFixedColumns'\n})\n```\n然后在template中渲染时，默认会渲染一个<table-body\\>,但是存在fixedColumns和rightFixedColumns时，分别都会增加一个<table-body\\>的渲染\n\n### ElTableBody（src\\table-body.js）\n而在ElTableBody中，实际使用render函数来渲染了全量数据，这几次的渲染不同只在与根据fixed传入把对应的列隐藏，\n其中渲染的关键部分为wrappedRowRender函数，\n```javascript\ndata.reduce((acc, row) => {\n  return acc.concat(this.wrappedRowRender(row, acc.length));\n}, [])\n```\n追踪wrappedRowRender，进一步到rowRender函数中，可以看到最终是渲染了表格的一行tr，\n而每个单元格cell的渲染则是通过column.renderCell渲染，这个值从哪来呢？\n答案是我们开始追踪的 ElTableColumn（src\\table-column.js） 中的setColumnRenders，\n主要部分如下：\n```javascript\ncolumn.renderCell = (h, data) => {\n  let children = null;\n  if (this.$scopedSlots.default) {\n    // NOTE：我们主要关注的是这个路径\n    children = this.$scopedSlots.default(data);\n  } else {\n    children = originRenderCell(h, data);\n  }\n  const prefix = treeCellPrefix(h, data);\n  const props = {\n    class: 'cell',\n    style: {}\n  };\n  if (column.showOverflowTooltip) {\n    props.class += ' el-tooltip';\n    props.style = {width: (data.column.realWidth || data.column.width) - 1 + 'px'};\n  }\n  return (<div { ...props }>\n    { prefix }\n    { children }\n  </div>);\n};\n```\n可以看到，事实上单元格内渲染的是作用域插槽$scopedSlots中的内容，\n因此综合前文逻辑，可以得出其实我们写在el-table-column中的内容会被渲染多次，\n再看看我们代码中的逻辑\n```html\n<el-popover\n  :ref=\"'custom-popover'+scope.row.uuid\"\n  placement=\"top\"\n  @show=\"showChart(scope.row.uuid)\"\n>\n  <child-chart :ref=\"'childChart'+scope.row.uuid\" />\n  <i slot=\"reference\" class=\"el-icon-question\"></i>\n</el-popover>\n```\n```javascript\nshowChart(id) {\n  const attr = 'childChart' + id;\n  const popperAttr = 'custom-popover' + id;\n  if (this.$refs && this.$refs[attr]) {\n    this.$refs[attr].showChart().then(() => {\n      this.$refs[popperAttr] && this.$refs[popperAttr].updatePopper();\n    });\n  }\n}\n```\n结合vue中registerRef的实现\n```javascript\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  // 省略部分代码...\n  if (vnode.data.refInFor) {\n    if (!Array.isArray(refs[key])) {\n      refs[key] = [ref];\n    } else if (refs[key].indexOf(ref) < 0) {\n      // $flow-disable-line\n      refs[key].push(ref);\n    }\n  } else {\n    // NOTE：这里是实际走的逻辑\n    refs[key] = ref;\n  }\n  // 省略部分代码...\n}\n```\n由于我们的代码不在v-for中，实际采用的是refs[key] = ref，\n因此后一次渲染时，会把之前的refs[key]覆盖掉，\n导致最终refs[key]指向的是最后一次数据的组件实例。\n\n## 修复方案\n\n由于会多次渲染，所以可以增加一个自增的属性，从而区分不同的子组件实例，\n但是需要注意的是这边并不是第一次生成的实例就是需要的实例，\n因为组件在初始实例化时会有多次更新的情况，初始创建的实例可能会变成空，\n\n```javascript\n// Vue的源码中\nVue.extend = function (extendOptions) {\n    // 省略部分代码...\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    // 省略部分代码...\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    // 省略部分代码...\n};\n```\n找到mergeOptions\n```javascript\n  \nfunction mergeOptions(\n  parent,\n  child,\n  vm\n) {\n  // 省略部分代码...\n  normalizeProps(child, vm);\n  // 省略部分代码...\n}\n```\n找到normalizeProps\n```javascript\nfunction normalizeProps (options, vm) {\n  // 省略部分代码...\n  options.props = res; // 这边赋值会触发新的更新\n}\n```\n因此推荐是获取第一次生成的有内容的实例,修改的主要代码如下\n```javascript\n// 用于每次渲染生成不同id\ngenId(type, uuid) {\n    const key = `${type}-${uuid}`;\n    const val = this.idMap.get(key) || 1;\n    this.idMap.set(key, val + 1);\n    return `${key}-${val}`;\n},\nshowChart(id) {\n    // NOTE：\n    // ElTable中设置了带fixed的column时，会导致table-body渲染多次（这个是UI库的实现逻辑导致的）\n    // 重复渲染会导致表格body中的子组件被多次实例化\n    // 前面genId做自增id，这边取id最小的有内容的ref就是为了解决这个问题\n    // 需要注意的是如果要获取的子组件位于fixed的column中，那么需要取的实例的id会变化，需要按具体情况分析\n    const attr = `childChart-${id}-`;\n    const popperAttr = `custom-popover-${id}-`;\n    for (let name in this.$refs) {\n        if (name.startsWith(attr) && this.$refs[name]) {\n            const popperName = popperAttr + name.replace(attr, '');\n            const item = this.$refs[name];\n            item.showChart().then(() => {\n                this.$refs[popperName] && this.$refs[popperName].updatePopper();\n            });\n        }\n    }\n}\n```\n",
                "slug": "el-table-column设置fixed的影响",
                "published": 1,
                "date": "2025-01-29T08:12:13.862Z",
                "updated": "2025-02-04T06:31:35.054Z",
                "_id": "cm6q1s4oy0003f4wbb53e51ur",
                "comments": 1,
                "layout": "post",
                "photos": [],
                "content": "<h2 id=\"背景描述\"><a href=\"#背景描述\" class=\"headerlink\" title=\"背景描述\"></a>背景描述</h2><p>这几天在维护Vue2项目时产生了一个bug，表现为表格中的popover组件弹出后通过$refs去获取子组件操作属性突然失效了。<br>由于一开始只从展示效果上看到这个问题，控制台没有报错。所以一开始还陷入了误判，刚开始认为是某些改动导致相关属性失去了响应性。但是翻阅了下自己的代码，调整了一部分代码后，发现问题并没有解决，而且感觉代码确实也没啥问题，一下子尬住了。</p>\n<h3 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h3><p>{<br>  “element-ui”: “^2.13.0”,<br>  “vue”: “^2.6.10”<br>}</p>\n<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR;\"></a>TL;DR;</h2><p>Element-UI在实现Fixed效果的手段为：针对有Column设置Fixed的ElTable会重复渲染table的body部分，然后重叠body来实现定位效果。<br>而重复渲染table-body会导致表格体内的子元素被多次渲染，而多次渲染会导致$refs被覆盖为最后创建的一个。<br>不幸的是，最后创建的table-body是为fixed&#x3D;”right”特别构建的部分，虽然也<b style=\"color:red;\">渲染了整个表格</b>，但是<b style=\"color:red;\">仅展示右侧固定列部分</b>。这种情况下，通过$refs获取到的子组件就是在这个区域内的，但是，如果你想操作的恰好是左侧非固定列的部分，不好意思，bug来了，你拿到的只是一个看不到的元素。<br>所以出现这种问题的时候，比较快的解决方法是去除ElTable上所有column的fixed属性设置，如果想看具体原因和解决方案，还烦请您耐心看下文章后半部分。</p>\n<h2 id=\"复现代码\"><a href=\"#复现代码\" class=\"headerlink\" title=\"复现代码\"></a>复现代码</h2><p>参考<a href=\"https://github.com/jijiwuming/problem-reproduction/blob/main/src/components/table.vue\">problem-reproduction</a></p>\n<p>也可尝试<a href=\"https://stackblitz.com/edit/vue2-problem?file=src/components/table.vue\">在线编辑</a></p>\n<h2 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h2><p>由于这部分可以确认之前是正常的，但是具体出现问题的时间节点暂不明确，无奈，尝试了几个早期版本的镜像，希望能快速找到上一个正常的时间节点，对比代码差异来找原因。<br>好在运气不错，出问题的时间并不长，从镜像看恰好是一周前，与当前比只差了5个提交。<br>得，Code Review吧，然而，看了一圈：我寻思我也妹写啥相关的代码啊？<br>啧，改回去试试，很快啊，本地代码就起起来了，回退了几处看上去勉强相关的，不出所料，确实没相关。<br>这不就艹了么这，那就再试试没那么相关的，好家伙，到了发现是另一个el-table-column上设置fixed&#x3D;”right”就会有这个问题<br>我：地铁老人手机.jpg，不是，这又怎么着了嘛，这都不是table-column，这怎么挨上的啊？<br>当然，到了这一步，快速修复方案已经有了，就是把fixed&#x3D;”right”去掉，因此先急忙打了个补丁把线上问题糊上了<br>连一刻也没有为线上bug哀悼，下一刻赶到战场的是ElTable的源码实现</p>\n<h2 id=\"问题原因\"><a href=\"#问题原因\" class=\"headerlink\" title=\"问题原因\"></a>问题原因</h2><p>打开node_modules\\element-ui\\packages\\table\\src, 来看看是怎么个事吧</p>\n<h3 id=\"ElTableColumn（src-table-column-js）\"><a href=\"#ElTableColumn（src-table-column-js）\" class=\"headerlink\" title=\"ElTableColumn（src\\table-column.js）\"></a>ElTableColumn（src\\table-column.js）</h3><p>先来看 ElTableColumn ，可以在created看到fixed在传入后会被设置到this.columnConfig上，并且在registerComplexWatchers设置变化监听，不过由于我代码中是直接赋固定值的，因此只需关注this.columnConfig后续在mounted中被用于owner.store.commit(‘insertColumn’)就行。</p>\n<h3 id=\"ElTable——Store（src-store-index-js）\"><a href=\"#ElTable——Store（src-store-index-js）\" class=\"headerlink\" title=\"ElTable——Store（src\\store\\index.js）\"></a>ElTable——Store（src\\store\\index.js）</h3><p>上面的store其实在src的store下，实际就是用Vue.extend扩展出了一个Vue实例，起一个状态管理和追踪作用，可以看到insertColumn最终会执行到</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">table</span>.<span class=\"hljs-property\">$ready</span>) &#123; <span class=\"hljs-comment\">// 这边会在ElTable完成mounted后执行，所以第一轮加载时不会有fixed部分的渲染</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">updateColumns</span>(); <span class=\"hljs-comment\">// hack for dynamics insert column</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">scheduleLayout</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这边主要关注的还是updateColumns，在src\\store\\watcher.js中，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">updateColumns</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>  states.<span class=\"hljs-property\">fixedColumns</span> = _columns.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">column</span>) =&gt;</span> column.<span class=\"hljs-property\">fixed</span> === <span class=\"hljs-literal\">true</span> || column.<span class=\"hljs-property\">fixed</span> === <span class=\"hljs-string\">&#x27;left&#x27;</span>);<br>  states.<span class=\"hljs-property\">rightFixedColumns</span> = _columns.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">column</span>) =&gt;</span> column.<span class=\"hljs-property\">fixed</span> === <span class=\"hljs-string\">&#x27;right&#x27;</span>);<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这边能看到针对fixed的列会分别被分成fixedColumns和rightFixedColumns，<br>接下去再来看看ElTable中针对这些列数据的渲染，</p>\n<h3 id=\"ElTable（src-table-vue）\"><a href=\"#ElTable（src-table-vue）\" class=\"headerlink\" title=\"ElTable（src\\table.vue）\"></a>ElTable（src\\table.vue）</h3><p>可以在这边看到computed中设置了映射</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">...<span class=\"hljs-title function_\">mapStates</span>(&#123;<br>  <span class=\"hljs-attr\">selection</span>: <span class=\"hljs-string\">&#x27;selection&#x27;</span>,<br>  <span class=\"hljs-attr\">columns</span>: <span class=\"hljs-string\">&#x27;columns&#x27;</span>,<br>  <span class=\"hljs-attr\">tableData</span>: <span class=\"hljs-string\">&#x27;data&#x27;</span>,<br>  <span class=\"hljs-attr\">fixedColumns</span>: <span class=\"hljs-string\">&#x27;fixedColumns&#x27;</span>,<br>  <span class=\"hljs-attr\">rightFixedColumns</span>: <span class=\"hljs-string\">&#x27;rightFixedColumns&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>然后在template中渲染时，默认会渲染一个&lt;table-body&gt;,但是存在fixedColumns和rightFixedColumns时，分别都会增加一个&lt;table-body&gt;的渲染</p>\n<h3 id=\"ElTableBody（src-table-body-js）\"><a href=\"#ElTableBody（src-table-body-js）\" class=\"headerlink\" title=\"ElTableBody（src\\table-body.js）\"></a>ElTableBody（src\\table-body.js）</h3><p>而在ElTableBody中，实际使用render函数来渲染了全量数据，这几次的渲染不同只在与根据fixed传入把对应的列隐藏，<br>其中渲染的关键部分为wrappedRowRender函数，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">data.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, row</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> acc.<span class=\"hljs-title function_\">concat</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">wrappedRowRender</span>(row, acc.<span class=\"hljs-property\">length</span>));<br>&#125;, [])<br></code></pre></td></tr></table></figure>\n<p>追踪wrappedRowRender，进一步到rowRender函数中，可以看到最终是渲染了表格的一行tr，<br>而每个单元格cell的渲染则是通过column.renderCell渲染，这个值从哪来呢？<br>答案是我们开始追踪的 ElTableColumn（src\\table-column.js） 中的setColumnRenders，<br>主要部分如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">column.<span class=\"hljs-property\">renderCell</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">h, data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> children = <span class=\"hljs-literal\">null</span>;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$scopedSlots</span>.<span class=\"hljs-property\">default</span>) &#123;<br>    <span class=\"hljs-comment\">// NOTE：我们主要关注的是这个路径</span><br>    children = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$scopedSlots</span>.<span class=\"hljs-title function_\">default</span>(data);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    children = <span class=\"hljs-title function_\">originRenderCell</span>(h, data);<br>  &#125;<br>  <span class=\"hljs-keyword\">const</span> prefix = <span class=\"hljs-title function_\">treeCellPrefix</span>(h, data);<br>  <span class=\"hljs-keyword\">const</span> props = &#123;<br>    <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">&#x27;cell&#x27;</span>,<br>    <span class=\"hljs-attr\">style</span>: &#123;&#125;<br>  &#125;;<br>  <span class=\"hljs-keyword\">if</span> (column.<span class=\"hljs-property\">showOverflowTooltip</span>) &#123;<br>    props.<span class=\"hljs-property\">class</span> += <span class=\"hljs-string\">&#x27; el-tooltip&#x27;</span>;<br>    props.<span class=\"hljs-property\">style</span> = &#123;<span class=\"hljs-attr\">width</span>: (data.<span class=\"hljs-property\">column</span>.<span class=\"hljs-property\">realWidth</span> || data.<span class=\"hljs-property\">column</span>.<span class=\"hljs-property\">width</span>) - <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&#x27;px&#x27;</span>&#125;;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> (<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> &#123; <span class=\"hljs-attr\">...props</span> &#125;&gt;</span></span><br><span class=\"language-xml\">    &#123; prefix &#125;</span><br><span class=\"language-xml\">    &#123; children &#125;</span><br><span class=\"language-xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以看到，事实上单元格内渲染的是作用域插槽$scopedSlots中的内容，<br>因此综合前文逻辑，可以得出其实我们写在el-table-column中的内容会被渲染多次，<br>再看看我们代码中的逻辑</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-popover</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">:ref</span>=<span class=\"hljs-string\">&quot;&#x27;custom-popover&#x27;+scope.row.uuid&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">placement</span>=<span class=\"hljs-string\">&quot;top&quot;</span></span><br><span class=\"hljs-tag\">  @<span class=\"hljs-attr\">show</span>=<span class=\"hljs-string\">&quot;showChart(scope.row.uuid)&quot;</span></span><br><span class=\"hljs-tag\">&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-chart</span> <span class=\"hljs-attr\">:ref</span>=<span class=\"hljs-string\">&quot;&#x27;childChart&#x27;+scope.row.uuid&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">&quot;reference&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;el-icon-question&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-popover</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">showChart</span>(<span class=\"hljs-params\">id</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> attr = <span class=\"hljs-string\">&#x27;childChart&#x27;</span> + id;<br>  <span class=\"hljs-keyword\">const</span> popperAttr = <span class=\"hljs-string\">&#x27;custom-popover&#x27;</span> + id;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span> &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[attr]) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[attr].<span class=\"hljs-title function_\">showChart</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[popperAttr] &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[popperAttr].<span class=\"hljs-title function_\">updatePopper</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>结合vue中registerRef的实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">registerRef</span> (<span class=\"hljs-params\">vnode, isRemoval</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> key = vnode.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">ref</span>;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title function_\">isDef</span>(key)) &#123; <span class=\"hljs-keyword\">return</span> &#125;<br><br>  <span class=\"hljs-keyword\">var</span> vm = vnode.<span class=\"hljs-property\">context</span>;<br>  <span class=\"hljs-keyword\">var</span> ref = vnode.<span class=\"hljs-property\">componentInstance</span> || vnode.<span class=\"hljs-property\">elm</span>;<br>  <span class=\"hljs-keyword\">var</span> refs = vm.<span class=\"hljs-property\">$refs</span>;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>  <span class=\"hljs-keyword\">if</span> (vnode.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">refInFor</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(refs[key])) &#123;<br>      refs[key] = [ref];<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (refs[key].<span class=\"hljs-title function_\">indexOf</span>(ref) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-comment\">// $flow-disable-line</span><br>      refs[key].<span class=\"hljs-title function_\">push</span>(ref);<br>    &#125;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">// NOTE：这里是实际走的逻辑</span><br>    refs[key] = ref;<br>  &#125;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>由于我们的代码不在v-for中，实际采用的是refs[key] &#x3D; ref，<br>因此后一次渲染时，会把之前的refs[key]覆盖掉，<br>导致最终refs[key]指向的是最后一次数据的组件实例。</p>\n<h2 id=\"修复方案\"><a href=\"#修复方案\" class=\"headerlink\" title=\"修复方案\"></a>修复方案</h2><p>由于会多次渲染，所以可以增加一个自增的属性，从而区分不同的子组件实例，<br>但是需要注意的是这边并不是第一次生成的实例就是需要的实例，<br>因为组件在初始实例化时会有多次更新的情况，初始创建的实例可能会变成空，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Vue的源码中</span><br><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-property\">extend</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">extendOptions</span>) &#123;<br>    <span class=\"hljs-comment\">// 省略部分代码...</span><br>    <span class=\"hljs-keyword\">var</span> cachedCtors = extendOptions.<span class=\"hljs-property\">_Ctor</span> || (extendOptions.<span class=\"hljs-property\">_Ctor</span> = &#123;&#125;);<br>    <span class=\"hljs-keyword\">if</span> (cachedCtors[<span class=\"hljs-title class_\">SuperId</span>]) &#123;<br>      <span class=\"hljs-keyword\">return</span> cachedCtors[<span class=\"hljs-title class_\">SuperId</span>]<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 省略部分代码...</span><br>    <span class=\"hljs-title class_\">Sub</span>.<span class=\"hljs-property\">options</span> = <span class=\"hljs-title function_\">mergeOptions</span>(<br>      <span class=\"hljs-title class_\">Super</span>.<span class=\"hljs-property\">options</span>,<br>      extendOptions<br>    );<br>    <span class=\"hljs-comment\">// 省略部分代码...</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>找到mergeOptions</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">  <br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mergeOptions</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">  parent,</span><br><span class=\"hljs-params\">  child,</span><br><span class=\"hljs-params\">  vm</span><br><span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>  <span class=\"hljs-title function_\">normalizeProps</span>(child, vm);<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>找到normalizeProps</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">normalizeProps</span> (<span class=\"hljs-params\">options, vm</span>) &#123;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>  options.<span class=\"hljs-property\">props</span> = res; <span class=\"hljs-comment\">// 这边赋值会触发新的更新</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>因此推荐是获取第一次生成的有内容的实例,修改的主要代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 用于每次渲染生成不同id</span><br><span class=\"hljs-title function_\">genId</span>(<span class=\"hljs-params\">type, uuid</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;type&#125;</span>-<span class=\"hljs-subst\">$&#123;uuid&#125;</span>`</span>;<br>    <span class=\"hljs-keyword\">const</span> val = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">idMap</span>.<span class=\"hljs-title function_\">get</span>(key) || <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">idMap</span>.<span class=\"hljs-title function_\">set</span>(key, val + <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>-<span class=\"hljs-subst\">$&#123;val&#125;</span>`</span>;<br>&#125;,<br><span class=\"hljs-title function_\">showChart</span>(<span class=\"hljs-params\">id</span>) &#123;<br>    <span class=\"hljs-comment\">// NOTE：</span><br>    <span class=\"hljs-comment\">// ElTable中设置了带fixed的column时，会导致table-body渲染多次（这个是UI库的实现逻辑导致的）</span><br>    <span class=\"hljs-comment\">// 重复渲染会导致表格body中的子组件被多次实例化</span><br>    <span class=\"hljs-comment\">// 前面genId做自增id，这边取id最小的有内容的ref就是为了解决这个问题</span><br>    <span class=\"hljs-comment\">// 需要注意的是如果要获取的子组件位于fixed的column中，那么需要取的实例的id会变化，需要按具体情况分析</span><br>    <span class=\"hljs-keyword\">const</span> attr = <span class=\"hljs-string\">`childChart-<span class=\"hljs-subst\">$&#123;id&#125;</span>-`</span>;<br>    <span class=\"hljs-keyword\">const</span> popperAttr = <span class=\"hljs-string\">`custom-popover-<span class=\"hljs-subst\">$&#123;id&#125;</span>-`</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> name <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (name.<span class=\"hljs-title function_\">startsWith</span>(attr) &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[name]) &#123;<br>            <span class=\"hljs-keyword\">const</span> popperName = popperAttr + name.<span class=\"hljs-title function_\">replace</span>(attr, <span class=\"hljs-string\">&#x27;&#x27;</span>);<br>            <span class=\"hljs-keyword\">const</span> item = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[name];<br>            item.<span class=\"hljs-title function_\">showChart</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>                <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[popperName] &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[popperName].<span class=\"hljs-title function_\">updatePopper</span>();<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n",
                "excerpt": "",
                "more": "<h2 id=\"背景描述\"><a href=\"#背景描述\" class=\"headerlink\" title=\"背景描述\"></a>背景描述</h2><p>这几天在维护Vue2项目时产生了一个bug，表现为表格中的popover组件弹出后通过$refs去获取子组件操作属性突然失效了。<br>由于一开始只从展示效果上看到这个问题，控制台没有报错。所以一开始还陷入了误判，刚开始认为是某些改动导致相关属性失去了响应性。但是翻阅了下自己的代码，调整了一部分代码后，发现问题并没有解决，而且感觉代码确实也没啥问题，一下子尬住了。</p>\n<h3 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h3><p>{<br>  “element-ui”: “^2.13.0”,<br>  “vue”: “^2.6.10”<br>}</p>\n<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR;\"></a>TL;DR;</h2><p>Element-UI在实现Fixed效果的手段为：针对有Column设置Fixed的ElTable会重复渲染table的body部分，然后重叠body来实现定位效果。<br>而重复渲染table-body会导致表格体内的子元素被多次渲染，而多次渲染会导致$refs被覆盖为最后创建的一个。<br>不幸的是，最后创建的table-body是为fixed&#x3D;”right”特别构建的部分，虽然也<b style=\"color:red;\">渲染了整个表格</b>，但是<b style=\"color:red;\">仅展示右侧固定列部分</b>。这种情况下，通过$refs获取到的子组件就是在这个区域内的，但是，如果你想操作的恰好是左侧非固定列的部分，不好意思，bug来了，你拿到的只是一个看不到的元素。<br>所以出现这种问题的时候，比较快的解决方法是去除ElTable上所有column的fixed属性设置，如果想看具体原因和解决方案，还烦请您耐心看下文章后半部分。</p>\n<h2 id=\"复现代码\"><a href=\"#复现代码\" class=\"headerlink\" title=\"复现代码\"></a>复现代码</h2><p>参考<a href=\"https://github.com/jijiwuming/problem-reproduction/blob/main/src/components/table.vue\">problem-reproduction</a></p>\n<p>也可尝试<a href=\"https://stackblitz.com/edit/vue2-problem?file=src/components/table.vue\">在线编辑</a></p>\n<h2 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h2><p>由于这部分可以确认之前是正常的，但是具体出现问题的时间节点暂不明确，无奈，尝试了几个早期版本的镜像，希望能快速找到上一个正常的时间节点，对比代码差异来找原因。<br>好在运气不错，出问题的时间并不长，从镜像看恰好是一周前，与当前比只差了5个提交。<br>得，Code Review吧，然而，看了一圈：我寻思我也妹写啥相关的代码啊？<br>啧，改回去试试，很快啊，本地代码就起起来了，回退了几处看上去勉强相关的，不出所料，确实没相关。<br>这不就艹了么这，那就再试试没那么相关的，好家伙，到了发现是另一个el-table-column上设置fixed&#x3D;”right”就会有这个问题<br>我：地铁老人手机.jpg，不是，这又怎么着了嘛，这都不是table-column，这怎么挨上的啊？<br>当然，到了这一步，快速修复方案已经有了，就是把fixed&#x3D;”right”去掉，因此先急忙打了个补丁把线上问题糊上了<br>连一刻也没有为线上bug哀悼，下一刻赶到战场的是ElTable的源码实现</p>\n<h2 id=\"问题原因\"><a href=\"#问题原因\" class=\"headerlink\" title=\"问题原因\"></a>问题原因</h2><p>打开node_modules\\element-ui\\packages\\table\\src, 来看看是怎么个事吧</p>\n<h3 id=\"ElTableColumn（src-table-column-js）\"><a href=\"#ElTableColumn（src-table-column-js）\" class=\"headerlink\" title=\"ElTableColumn（src\\table-column.js）\"></a>ElTableColumn（src\\table-column.js）</h3><p>先来看 ElTableColumn ，可以在created看到fixed在传入后会被设置到this.columnConfig上，并且在registerComplexWatchers设置变化监听，不过由于我代码中是直接赋固定值的，因此只需关注this.columnConfig后续在mounted中被用于owner.store.commit(‘insertColumn’)就行。</p>\n<h3 id=\"ElTable——Store（src-store-index-js）\"><a href=\"#ElTable——Store（src-store-index-js）\" class=\"headerlink\" title=\"ElTable——Store（src\\store\\index.js）\"></a>ElTable——Store（src\\store\\index.js）</h3><p>上面的store其实在src的store下，实际就是用Vue.extend扩展出了一个Vue实例，起一个状态管理和追踪作用，可以看到insertColumn最终会执行到</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">table</span>.<span class=\"hljs-property\">$ready</span>) &#123; <span class=\"hljs-comment\">// 这边会在ElTable完成mounted后执行，所以第一轮加载时不会有fixed部分的渲染</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">updateColumns</span>(); <span class=\"hljs-comment\">// hack for dynamics insert column</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">scheduleLayout</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这边主要关注的还是updateColumns，在src\\store\\watcher.js中，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">updateColumns</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>  states.<span class=\"hljs-property\">fixedColumns</span> = _columns.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">column</span>) =&gt;</span> column.<span class=\"hljs-property\">fixed</span> === <span class=\"hljs-literal\">true</span> || column.<span class=\"hljs-property\">fixed</span> === <span class=\"hljs-string\">&#x27;left&#x27;</span>);<br>  states.<span class=\"hljs-property\">rightFixedColumns</span> = _columns.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">column</span>) =&gt;</span> column.<span class=\"hljs-property\">fixed</span> === <span class=\"hljs-string\">&#x27;right&#x27;</span>);<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这边能看到针对fixed的列会分别被分成fixedColumns和rightFixedColumns，<br>接下去再来看看ElTable中针对这些列数据的渲染，</p>\n<h3 id=\"ElTable（src-table-vue）\"><a href=\"#ElTable（src-table-vue）\" class=\"headerlink\" title=\"ElTable（src\\table.vue）\"></a>ElTable（src\\table.vue）</h3><p>可以在这边看到computed中设置了映射</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">...<span class=\"hljs-title function_\">mapStates</span>(&#123;<br>  <span class=\"hljs-attr\">selection</span>: <span class=\"hljs-string\">&#x27;selection&#x27;</span>,<br>  <span class=\"hljs-attr\">columns</span>: <span class=\"hljs-string\">&#x27;columns&#x27;</span>,<br>  <span class=\"hljs-attr\">tableData</span>: <span class=\"hljs-string\">&#x27;data&#x27;</span>,<br>  <span class=\"hljs-attr\">fixedColumns</span>: <span class=\"hljs-string\">&#x27;fixedColumns&#x27;</span>,<br>  <span class=\"hljs-attr\">rightFixedColumns</span>: <span class=\"hljs-string\">&#x27;rightFixedColumns&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>然后在template中渲染时，默认会渲染一个&lt;table-body&gt;,但是存在fixedColumns和rightFixedColumns时，分别都会增加一个&lt;table-body&gt;的渲染</p>\n<h3 id=\"ElTableBody（src-table-body-js）\"><a href=\"#ElTableBody（src-table-body-js）\" class=\"headerlink\" title=\"ElTableBody（src\\table-body.js）\"></a>ElTableBody（src\\table-body.js）</h3><p>而在ElTableBody中，实际使用render函数来渲染了全量数据，这几次的渲染不同只在与根据fixed传入把对应的列隐藏，<br>其中渲染的关键部分为wrappedRowRender函数，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">data.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, row</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> acc.<span class=\"hljs-title function_\">concat</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">wrappedRowRender</span>(row, acc.<span class=\"hljs-property\">length</span>));<br>&#125;, [])<br></code></pre></td></tr></table></figure>\n<p>追踪wrappedRowRender，进一步到rowRender函数中，可以看到最终是渲染了表格的一行tr，<br>而每个单元格cell的渲染则是通过column.renderCell渲染，这个值从哪来呢？<br>答案是我们开始追踪的 ElTableColumn（src\\table-column.js） 中的setColumnRenders，<br>主要部分如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">column.<span class=\"hljs-property\">renderCell</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">h, data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> children = <span class=\"hljs-literal\">null</span>;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$scopedSlots</span>.<span class=\"hljs-property\">default</span>) &#123;<br>    <span class=\"hljs-comment\">// NOTE：我们主要关注的是这个路径</span><br>    children = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$scopedSlots</span>.<span class=\"hljs-title function_\">default</span>(data);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    children = <span class=\"hljs-title function_\">originRenderCell</span>(h, data);<br>  &#125;<br>  <span class=\"hljs-keyword\">const</span> prefix = <span class=\"hljs-title function_\">treeCellPrefix</span>(h, data);<br>  <span class=\"hljs-keyword\">const</span> props = &#123;<br>    <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">&#x27;cell&#x27;</span>,<br>    <span class=\"hljs-attr\">style</span>: &#123;&#125;<br>  &#125;;<br>  <span class=\"hljs-keyword\">if</span> (column.<span class=\"hljs-property\">showOverflowTooltip</span>) &#123;<br>    props.<span class=\"hljs-property\">class</span> += <span class=\"hljs-string\">&#x27; el-tooltip&#x27;</span>;<br>    props.<span class=\"hljs-property\">style</span> = &#123;<span class=\"hljs-attr\">width</span>: (data.<span class=\"hljs-property\">column</span>.<span class=\"hljs-property\">realWidth</span> || data.<span class=\"hljs-property\">column</span>.<span class=\"hljs-property\">width</span>) - <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&#x27;px&#x27;</span>&#125;;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> (<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> &#123; <span class=\"hljs-attr\">...props</span> &#125;&gt;</span></span><br><span class=\"language-xml\">    &#123; prefix &#125;</span><br><span class=\"language-xml\">    &#123; children &#125;</span><br><span class=\"language-xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以看到，事实上单元格内渲染的是作用域插槽$scopedSlots中的内容，<br>因此综合前文逻辑，可以得出其实我们写在el-table-column中的内容会被渲染多次，<br>再看看我们代码中的逻辑</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-popover</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">:ref</span>=<span class=\"hljs-string\">&quot;&#x27;custom-popover&#x27;+scope.row.uuid&quot;</span></span><br><span class=\"hljs-tag\">  <span class=\"hljs-attr\">placement</span>=<span class=\"hljs-string\">&quot;top&quot;</span></span><br><span class=\"hljs-tag\">  @<span class=\"hljs-attr\">show</span>=<span class=\"hljs-string\">&quot;showChart(scope.row.uuid)&quot;</span></span><br><span class=\"hljs-tag\">&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-chart</span> <span class=\"hljs-attr\">:ref</span>=<span class=\"hljs-string\">&quot;&#x27;childChart&#x27;+scope.row.uuid&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">&quot;reference&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;el-icon-question&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-popover</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">showChart</span>(<span class=\"hljs-params\">id</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> attr = <span class=\"hljs-string\">&#x27;childChart&#x27;</span> + id;<br>  <span class=\"hljs-keyword\">const</span> popperAttr = <span class=\"hljs-string\">&#x27;custom-popover&#x27;</span> + id;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span> &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[attr]) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[attr].<span class=\"hljs-title function_\">showChart</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[popperAttr] &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[popperAttr].<span class=\"hljs-title function_\">updatePopper</span>();<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>结合vue中registerRef的实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">registerRef</span> (<span class=\"hljs-params\">vnode, isRemoval</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> key = vnode.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">ref</span>;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title function_\">isDef</span>(key)) &#123; <span class=\"hljs-keyword\">return</span> &#125;<br><br>  <span class=\"hljs-keyword\">var</span> vm = vnode.<span class=\"hljs-property\">context</span>;<br>  <span class=\"hljs-keyword\">var</span> ref = vnode.<span class=\"hljs-property\">componentInstance</span> || vnode.<span class=\"hljs-property\">elm</span>;<br>  <span class=\"hljs-keyword\">var</span> refs = vm.<span class=\"hljs-property\">$refs</span>;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>  <span class=\"hljs-keyword\">if</span> (vnode.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">refInFor</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(refs[key])) &#123;<br>      refs[key] = [ref];<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (refs[key].<span class=\"hljs-title function_\">indexOf</span>(ref) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-comment\">// $flow-disable-line</span><br>      refs[key].<span class=\"hljs-title function_\">push</span>(ref);<br>    &#125;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">// NOTE：这里是实际走的逻辑</span><br>    refs[key] = ref;<br>  &#125;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>由于我们的代码不在v-for中，实际采用的是refs[key] &#x3D; ref，<br>因此后一次渲染时，会把之前的refs[key]覆盖掉，<br>导致最终refs[key]指向的是最后一次数据的组件实例。</p>\n<h2 id=\"修复方案\"><a href=\"#修复方案\" class=\"headerlink\" title=\"修复方案\"></a>修复方案</h2><p>由于会多次渲染，所以可以增加一个自增的属性，从而区分不同的子组件实例，<br>但是需要注意的是这边并不是第一次生成的实例就是需要的实例，<br>因为组件在初始实例化时会有多次更新的情况，初始创建的实例可能会变成空，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Vue的源码中</span><br><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-property\">extend</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">extendOptions</span>) &#123;<br>    <span class=\"hljs-comment\">// 省略部分代码...</span><br>    <span class=\"hljs-keyword\">var</span> cachedCtors = extendOptions.<span class=\"hljs-property\">_Ctor</span> || (extendOptions.<span class=\"hljs-property\">_Ctor</span> = &#123;&#125;);<br>    <span class=\"hljs-keyword\">if</span> (cachedCtors[<span class=\"hljs-title class_\">SuperId</span>]) &#123;<br>      <span class=\"hljs-keyword\">return</span> cachedCtors[<span class=\"hljs-title class_\">SuperId</span>]<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 省略部分代码...</span><br>    <span class=\"hljs-title class_\">Sub</span>.<span class=\"hljs-property\">options</span> = <span class=\"hljs-title function_\">mergeOptions</span>(<br>      <span class=\"hljs-title class_\">Super</span>.<span class=\"hljs-property\">options</span>,<br>      extendOptions<br>    );<br>    <span class=\"hljs-comment\">// 省略部分代码...</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>找到mergeOptions</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">  <br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mergeOptions</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">  parent,</span><br><span class=\"hljs-params\">  child,</span><br><span class=\"hljs-params\">  vm</span><br><span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>  <span class=\"hljs-title function_\">normalizeProps</span>(child, vm);<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>找到normalizeProps</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">normalizeProps</span> (<span class=\"hljs-params\">options, vm</span>) &#123;<br>  <span class=\"hljs-comment\">// 省略部分代码...</span><br>  options.<span class=\"hljs-property\">props</span> = res; <span class=\"hljs-comment\">// 这边赋值会触发新的更新</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>因此推荐是获取第一次生成的有内容的实例,修改的主要代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 用于每次渲染生成不同id</span><br><span class=\"hljs-title function_\">genId</span>(<span class=\"hljs-params\">type, uuid</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;type&#125;</span>-<span class=\"hljs-subst\">$&#123;uuid&#125;</span>`</span>;<br>    <span class=\"hljs-keyword\">const</span> val = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">idMap</span>.<span class=\"hljs-title function_\">get</span>(key) || <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">idMap</span>.<span class=\"hljs-title function_\">set</span>(key, val + <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>-<span class=\"hljs-subst\">$&#123;val&#125;</span>`</span>;<br>&#125;,<br><span class=\"hljs-title function_\">showChart</span>(<span class=\"hljs-params\">id</span>) &#123;<br>    <span class=\"hljs-comment\">// NOTE：</span><br>    <span class=\"hljs-comment\">// ElTable中设置了带fixed的column时，会导致table-body渲染多次（这个是UI库的实现逻辑导致的）</span><br>    <span class=\"hljs-comment\">// 重复渲染会导致表格body中的子组件被多次实例化</span><br>    <span class=\"hljs-comment\">// 前面genId做自增id，这边取id最小的有内容的ref就是为了解决这个问题</span><br>    <span class=\"hljs-comment\">// 需要注意的是如果要获取的子组件位于fixed的column中，那么需要取的实例的id会变化，需要按具体情况分析</span><br>    <span class=\"hljs-keyword\">const</span> attr = <span class=\"hljs-string\">`childChart-<span class=\"hljs-subst\">$&#123;id&#125;</span>-`</span>;<br>    <span class=\"hljs-keyword\">const</span> popperAttr = <span class=\"hljs-string\">`custom-popover-<span class=\"hljs-subst\">$&#123;id&#125;</span>-`</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> name <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (name.<span class=\"hljs-title function_\">startsWith</span>(attr) &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[name]) &#123;<br>            <span class=\"hljs-keyword\">const</span> popperName = popperAttr + name.<span class=\"hljs-title function_\">replace</span>(attr, <span class=\"hljs-string\">&#x27;&#x27;</span>);<br>            <span class=\"hljs-keyword\">const</span> item = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[name];<br>            item.<span class=\"hljs-title function_\">showChart</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>                <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[popperName] &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$refs</span>[popperName].<span class=\"hljs-title function_\">updatePopper</span>();<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n"
            },
            {
                "title": "樊笼",
                "_content": "\n又近岁末，感慨良多，自觉鸟困樊笼，难得自在。\n<!-- more -->\n\n### 不该是这样的\n\n不觉已是工作多年，身边的人一个个结婚生子，升职加薪，在朋友圈里分享着绚丽的生活。\n\n只有自己，却好像NPC一般，没啥变化，更没啥长进。\n\n工作日上班、睡觉，休息日报复性的游戏、视频，仿佛这些就是全部的生活。\n\n依稀记得以前不是这样的，但为什么变成了这样呢？不该是这样的。\n\n午夜梦回，仿佛昨天还是刚踏出校门的样子；一朝醒转，转眼却已经是奔三的年纪了。\n\n倏忽间，想起一句诗\n\n> 劝君莫惜金缕衣，劝君惜取少年时\n\n虽已不再年少，犹有可为之事，便无凌云之志，亦当拾级而上",
                "source": "_posts/樊笼.md",
                "raw": "---\ntitle: 樊笼\ncategories: [碎碎念]\n---\n\n又近岁末，感慨良多，自觉鸟困樊笼，难得自在。\n<!-- more -->\n\n### 不该是这样的\n\n不觉已是工作多年，身边的人一个个结婚生子，升职加薪，在朋友圈里分享着绚丽的生活。\n\n只有自己，却好像NPC一般，没啥变化，更没啥长进。\n\n工作日上班、睡觉，休息日报复性的游戏、视频，仿佛这些就是全部的生活。\n\n依稀记得以前不是这样的，但为什么变成了这样呢？不该是这样的。\n\n午夜梦回，仿佛昨天还是刚踏出校门的样子；一朝醒转，转眼却已经是奔三的年纪了。\n\n倏忽间，想起一句诗\n\n> 劝君莫惜金缕衣，劝君惜取少年时\n\n虽已不再年少，犹有可为之事，便无凌云之志，亦当拾级而上",
                "slug": "樊笼",
                "published": 1,
                "date": "2024-11-09T08:06:54.800Z",
                "updated": "2025-02-04T06:44:45.818Z",
                "_id": "cm6q1s4p4000hf4wb7yad8eke",
                "comments": 1,
                "layout": "post",
                "photos": [],
                "content": "<p>又近岁末，感慨良多，自觉鸟困樊笼，难得自在。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"不该是这样的\"><a href=\"#不该是这样的\" class=\"headerlink\" title=\"不该是这样的\"></a>不该是这样的</h3><p>不觉已是工作多年，身边的人一个个结婚生子，升职加薪，在朋友圈里分享着绚丽的生活。</p>\n<p>只有自己，却好像NPC一般，没啥变化，更没啥长进。</p>\n<p>工作日上班、睡觉，休息日报复性的游戏、视频，仿佛这些就是全部的生活。</p>\n<p>依稀记得以前不是这样的，但为什么变成了这样呢？不该是这样的。</p>\n<p>午夜梦回，仿佛昨天还是刚踏出校门的样子；一朝醒转，转眼却已经是奔三的年纪了。</p>\n<p>倏忽间，想起一句诗</p>\n<blockquote>\n<p>劝君莫惜金缕衣，劝君惜取少年时</p>\n</blockquote>\n<p>虽已不再年少，犹有可为之事，便无凌云之志，亦当拾级而上</p>\n",
                "excerpt": "<p>又近岁末，感慨良多，自觉鸟困樊笼，难得自在。</p>",
                "more": "<h3 id=\"不该是这样的\"><a href=\"#不该是这样的\" class=\"headerlink\" title=\"不该是这样的\"></a>不该是这样的</h3><p>不觉已是工作多年，身边的人一个个结婚生子，升职加薪，在朋友圈里分享着绚丽的生活。</p>\n<p>只有自己，却好像NPC一般，没啥变化，更没啥长进。</p>\n<p>工作日上班、睡觉，休息日报复性的游戏、视频，仿佛这些就是全部的生活。</p>\n<p>依稀记得以前不是这样的，但为什么变成了这样呢？不该是这样的。</p>\n<p>午夜梦回，仿佛昨天还是刚踏出校门的样子；一朝醒转，转眼却已经是奔三的年纪了。</p>\n<p>倏忽间，想起一句诗</p>\n<blockquote>\n<p>劝君莫惜金缕衣，劝君惜取少年时</p>\n</blockquote>\n<p>虽已不再年少，犹有可为之事，便无凌云之志，亦当拾级而上</p>"
            }
        ],
        "PostAsset": [],
        "PostCategory": [
            {
                "post_id": "cm6q1s4ov0001f4wbchyn0bz8",
                "category_id": "cm6q1s4oz0004f4wb1gt22rtz",
                "_id": "cm6q1s4p20009f4wb58hzg0g5"
            },
            {
                "post_id": "cm6q1s4oy0003f4wbb53e51ur",
                "category_id": "cm6q1s4oz0004f4wb1gt22rtz",
                "_id": "cm6q1s4p3000cf4wb6fvw8hp3"
            },
            {
                "post_id": "cm6q1s4p4000hf4wb7yad8eke",
                "category_id": "cm6q1s4p5000if4wb20dr2qsl",
                "_id": "cm6q1s4p5000jf4wb3drse8ke"
            }
        ],
        "PostTag": [
            {
                "post_id": "cm6q1s4ov0001f4wbchyn0bz8",
                "tag_id": "cm6q1s4p00005f4wb3zl678wo",
                "_id": "cm6q1s4p3000bf4wbfe6q0thx"
            },
            {
                "post_id": "cm6q1s4ov0001f4wbchyn0bz8",
                "tag_id": "cm6q1s4p10008f4wb1dqnh2ja",
                "_id": "cm6q1s4p3000df4wbfkuo5sc9"
            },
            {
                "post_id": "cm6q1s4oy0003f4wbb53e51ur",
                "tag_id": "cm6q1s4p00005f4wb3zl678wo",
                "_id": "cm6q1s4p3000ff4wbclh2f51j"
            },
            {
                "post_id": "cm6q1s4oy0003f4wbb53e51ur",
                "tag_id": "cm6q1s4p10008f4wb1dqnh2ja",
                "_id": "cm6q1s4p3000gf4wb2cgt6d7w"
            }
        ],
        "Tag": [
            {
                "name": "vue 2",
                "_id": "cm6q1s4p00005f4wb3zl678wo"
            },
            {
                "name": "element-ui",
                "_id": "cm6q1s4p10008f4wb1dqnh2ja"
            }
        ]
    }
}